* write in-language thing first
oho, I can do it subtractively:
I'll write the in-language typed interfaces article first.

Use the type system in your language, not RPC stuff
(and extend it over the network)


um, I can talk about. the...
value of using in-language abstractions and things, which you can't do otherwise.

(hey this is related to the config article)

and also make the sandboxing point, that you don't have to sacrifice sandboxing and stuff.
even if you want complete control...

maybe I should even title it, "you can extend your language's type system across the network",
and across time (persistence in the filesystem), etc.

type safety doesn't.. hm.
type safety doesn't require global checking, that's the entire point, ya dummies.

anyway uhhh maybe that slogan is too obscure to need debunking

title: Use the language's type system, not a separate weaker type system, wherever possible

title: Write down types with your language, not separate code generators, wherever possible

title: Don't sacrifice the richness of the built-in type system of your language too easily


title: Use the abstractions of your language, not separate tools, wherever possible

oh yeah it's really important to not say type systems here actually,
because, it's confusing if I say type systems!
it's much better to focus on the abstraction power that the language provides...

title: Use language-level abstractions, not hardware-level abstractions, wherever possible

that's pretty vague...

title: Use language-level abstractions, not OS-level abstractions, wherever possible

umm they aren't just OS-level...

title: Use language-level abstractions, not weaker language-independent abstractions, wherever possible

um sure, that's one thing to say...

yeah, I think that's actually really what I mean!
** related to
http://catern.com/config.html
http://catern.com/progsys.html
** points
*** passing function pointers around is useful
and, objects behind interfaces, etc
*** types, obviously, are useful
*** you can still sandbox, you can still separate privilege levels
** different framing
The general-purpose programming language is the best tool for abstraction we know.

Try to keep your abstractions in your general-purpose programming language.

Don't use external... things
** abstraction inversion
abstraction inversion is maybe a misnomer

basically don't build new abstractions when the ones you have are perfectly good!

is it really inversion...?

oh, it's abstraction inversion because you're building those abstractions,
using a language that already has module support.
** just saying
The programming language is good. Use it.

title: Your general-purpose programming language already has all the abstractive power you need

or something like that...

stop building new abstractions outside the language.


"title": The modern programming language is the most powerful abstraction engine known to humanity

Use your programming language to build abstractions, not 

title: Build abstractions inside your programming system, not outside, wherever possible

aha okay that's key, that's key. inside, not outside, wherever possible.

Abstract inside the system, not outside, wherever possible.

(but... I like code generation, don't I...?)
(well, that's still within the system, essentially)

oh so really I'm suggesting, don't build new abstractions on top.

Your programming language probably already has enough abstractive power.

um, okay, so, another further direction would be just,
"stop building new abstractions on top of things!"

like, my general principle is,
the existing system probably has enough power.

but I guess I don't want to make that general point here...

okay but still, that's yet another third article I guess?

like...

okay so, I guess maybe I'm not generally 100% against abstraction. hm.

maybe I only like reducing abstractions to the more powerful thing?

nah...

well, I mean, I like reducing them to Unix or reducing them to the programming language.

but I do like reducing abstractions, in any scenario.

title: Try to implement new features in terms of features you already have

I think that's a really clear and cogent expression of what I'm about, yeah...

(and the application of that principle to programming languages, gives us the preference for libraries over RPC)

aha okay okay Boopy says this is a good title and all, but, uh...
isn't that just code reuse lol?

code reuse is good...

code... REUSE!!!

"but abstractions let you reuse code better..."

um well, um!! well!!! you already have enough abstractions, you don't need any more.

(((YAGNI is basically a way of saying code reuse???)))

well let's forget that, but, yeah!

reuse code!
don't build new features, use the features you already have.

oh, actually... it's more like...
reuse complexity.

don't just reuse code, reuse complexity.

if you've already spent your complexity budget on some interface,
keep using it! as much as you can!

same as, like, programming!

If you've already built or got an abstraction, use it!

Make your copmlexity/abstractions do double duty for multiple things

If you've already got an abstraction that can do one thing, don't build another one!

The great virtue of code reuse is not that it can let you reuse code;
it's that it can let you reuse complexity, reuse abstractions,
gain more benefits from the complexity costs you've already paid.

So don't build your stuff for code reuse;
but still, recognize when a new use case is fundamentally the same as something you've already done!

And reuse that old abstraction!

(maybe even, "don't reuse code, reuse complexity"?)

The great virtue of code reuse is not that it can save you time on implementation
but that you have a fixed complexity budget,
and it lets you avoiding spending more,
by using something you've already paid for.


If you already have an interface,
don't just poke a new hole in it for every new thing you want to do.
See if you can express the new thing in terms of what you can already do!

Don't add a new thing in your implementation;
write a script in front of your interface!
Even if it's more code total,
it's less functionality in the interface,
and that it makes it easier to preserve your invariants,
and that's less complexity,

Many have tried to make software reuse easier;
it was a hot topic and motivated huge amounts of research in the 1990s and 2000s.

but y'know...
I think the thing to do is to reuse complexity you've already expended in your program.

The real difficult thing was building the theory behind that code, try to reuse that!

if code is simple (like hello world), reuse is pointless
the thing you want to reuse is complexity

if code can be mechanically reproduced without thought,
(like setup functions)
then making some framework for reuse will only increase complexity, not decrease it.

if you can just look at the code and see what it does...
if the code is using an underlying API that's good and simple...
than abstracting the code for reuse will just add complexity.

don't abstract and reuse simple things.
only abstract and reuse complex things.
(well, what's simple? don't some people probably think the setup code is not simple?)

Don't reuse code, reuse complexity

Or...

Reuse complexity, not code

Complexity reuse, not code reuse

eh still best:

Don't reuse code, reuse complexity

well, a just is good...

Don't just reuse code, reuse complexity

anyway!
** most complexity is in the interfaces
uhhh I'm not sure I believe that,
I could have some code with a "do it!" interface that just does everything.
** points
*** opening
The great virtue of code reuse is not that it can save you time on implementation
but that you have a fixed complexity budget,
and it lets you avoiding spending more,
by using something you've already paid for.
*** abstraction inversion
*** relationship of "YAGNI" and "do the simplest thing that works" with this
 well...

 yeah, basically I regard that as saying that,
 the code you're writing isn't complex.
 it's using complex abstractions which already exist to make things easier.

 to make a new abstraction to write your code on top of,
 would be spending complexity,
 and it's not likely that the way you're spending that complexity will be better than the existing APIs.
 By using those existing APIs, you're saving your complexity budget.

 Sometimes it can be useful,
 but most of the time it's misguided.
*** simple code doesn't need to be reused
*** programming languages and operating systems
** shower musings
it may be more code but it's less complexity

you might have to change abstractions in a way that seems unrelated to your goal

two of the biggest and most complex abstractions are the programming language and the operation system

If we only cared about reusing code, we'd be indifferent to whether new code was written inside or outside the interface
** um
If you can make a small tweak to an existing interface...

that's not always necessarily good.
sometimes it's preferable to build a whole new interface!

maybe I should be concrete...
** basic-sounding paragraphs
# these two paragraphs are very basic stuff.
# maybe I shouldn't write these...
# I want to focus more on, how you should reuse the hard task of building an abstraction that works!
Prefer to write more code outside the interface,
than to write less code inside the implementation of the interface.
If we only cared about reusing code,
we'd be indifferent to whether we are inside or outside.
But code which is inside an interface,
and needs to maintain the invariants of that interface,
is more complex than code which is outside the interface.

If you must change the interface,
prefer to make a smaller change than a larger one.
If you embrace writing code outside the interface,
the change you might make to the interface may seem entirely unrelated to your goal;
it may be the last required feature to perform some task entirely outside the interface.
And adding that one small feature to the interface may be less complex
than achieving your entire goal inside the interface.
** better framing
If you can express a problem in terms of an existing abstraction,
you'll save a lot of effort.
you might write more code,
but the code will be less complex,
because you'll be reusing the complexity that went into the existing abstraction.

two of the most powerful existing abstractions
are the programming language and the operating system.
** use programming languages/OS as example
nice, nice idea, that can be my example, yes.
** stray paragraphs
*** 
If you can reduce your problem to an interaction purely in terms of these existing abstractions,
you'll save a great deal of complexity.
Even if you add a small additional abstraction
on top of what's already available in the platform,
you'll save complexity.
** post
title: Don't just reuse code, reuse complexity

# clumsy phrasing?
The real advantage of "code reuse" is not writing less code.
It's saving your complexity budget.
If you can reuse an abstraction for a new purpose,
you don't have to pay the complexity budget of creating a new abstraction.

If you can express a problem in terms of an existing abstraction,
you'll save a lot of effort.
You might write more code,
but the code will be less complex,
because you'll be reusing the complexity that went into the existing abstraction.
# note about adding additional abstractions/complexity on top?
# incrementally instead of building something totally new?
# I can put that afterwards, I guess?

You might be tempted to build a new abstraction on top;
or to discard the abstraction and modify the internals directly.
Those are easy in the short term,
but hard in the long term,
because they increase the complexity of your system.
If you can express something in terms of what's already supported,
you'll win out.

There's an issue sometimes called "abstraction inversion".
Abstraction inversion is what happens when you build a new abstraction
on top of an existing abstraction,
but your new abstraction is less powerful than the existing one.
Then you've added more complexity to the system.
That complexity might be worth it - if you're going to use your new abstraction a lot.
You can't know that up front.
By using the existing APIs,
you're saving your complexity budget until you really need it.

for the benefit of 
instead of reusing

but the best way is to perform the twisty thinking require
is to 
or to extend the 
The thinking required 
For example,
if an interface supports a certain operation,

Two of the biggest and most complex abstractions you have available
are the general-purpose programming language you're writing,
and the operating system you're running on.
You can't get rid of them;
so, instead, use them!

Many higher-level abstractions have been created on top or alongside these existing abstractions.
But these don't remove the underlying complexity;
they just add more,
to make certain things easier and make other things harder.

There are many ways to reuse the abstractions



In particular, many abstractions have been created for modularity outside a programming language,
But these are sacrificing an opportunity to reuse complexity:
Most general-purpose programming languages already have lots of support for modular programming built in.



You may still need to change the interface to achieve your goal.

you might be able to make a small change to the interface,
and write most of the code outside the interface,
rather than make a big change to the interface and 
** argh
it's really so simple what I want to express!

I just want to say,
use the abstractions you already have!

um.
is that what I want to say?

okay, let's try again.

I really just want to say:
you have...


okay and one of these things is like,
keeping the abstraction close to what you already have.

(libposdelta? was it successful? mmmm well...)


use what you already have! come on! that's the core!

Use the abstractions you already have.
Don't write new abstractions.
Don't write new abstractions.
Don't write new abstractions.

The reason you can get away with not writing new abstractions,
the reason "you ain't gonna need it" is such good advice,
the reason you should do the simplest thing that works,
is because you're building on a tower of abstractions that already are high quality and have stood the test of time.

When you make new components,
make them within the abstractions that already exist.

There's two very powerful and widespread abstractions:
The general-purpose programming language you're writing in,
and the operating system you're running on.

You can pick between them based on your taste,
and based on the problem area,
but between them you've got a great deal of abstractive power.

You might not know all the abstractions that your operating system and your programming language provide.
Well, if you don't,
you're even less likely to build something new when you decide to build a new abstraction.

And there's a wealth of other abstractions available;
many projects have come and gone,
and they provide a rich collection of models for almost any problem.
*** hm
is this really the key though?

people already know to use the abstractions they already have, and to not write new ones...

I guess what I'm saying is, build things within those abstractions?
the PL and OS have building blocks for making new abstractions;
use them rather than starting from scratch.

maybe I should have a stack of, like:
your software has existing features - use them!
you have a framework you're building in - use it!
that uses libraries - use them!
that runs on a programming language - use it!
that runs on an OS - use it!

there's lot of abstractions already,
you can use them and solve your new problem within that framework,
rather than by building something new.

the parts of that stack which have stood the test of time are the lowest ones.
those provide abstractions that are widespread and powerful.

you should actually use their power of abstraction,
rather than just treating them as a dumb platform that you build your own new thing on top of.

but yeah...
ummmm so, is it really the key?
as people already know to reuse abstractions, etc.

work *with* the abstractions, not against them!
*** walking notes
Maybe I'm just saying, code/abstraction reuse is easier than you think?

The thing you want to do can be done with the abstractions you already have

People systematically underuse the abstractions they already have

There are more code reuse opportunities than you think

Forget code reuse - spend more time on complexity reuse

Or at least... The abstractions you have are more powerful than you think (but how can I know that?)

Keep your abstractions small and orthogonal? Well a bazillion people have already said that...

Like the CPU isolation thing...

Just think harder about ways to do things without introducing new APIs and new complexity! Blah!

But obviously that's a bit useless as advice.

Maybe this is too general?
I'm saying, use existing abstractions, but that's hard to sustain in general, so maybe I should focus on PL and OS?

Like... What's the issue people had?

I guess... It could be that they are always feeling like it's easier to make a new thing,
than to modify something that exists? Or to use something that exists in a new way?

Stop writing new software, use what you already have, for once!

I mean, that's repeating myself.
But basically, too much fear of changing existing abstractions and too much prioritization of making new things...

You should think harder about reusing existing code...

Well no, again! That is not the issue!

That's part of it, but part of it is also just fear of existing stuff! Fear of changing it!

So, maybe I can say don't fear existing code

Don't fear existing code and existing abstractions - learn them!

Use them! Change them, if necessary!

Determine whether code and its abstractions are high quality or low quality

(Old, widely used, open source) vs (new, rarely used, proprietary or local to one company)

And the ones that are high quality, use them!

Two such ones are the PL and OS

Don't fear existing abstractions; use them!
*** use exisitng code
okay, I like this framing, sure.

don't fear working with existing abstractions.

boopy fears it because he doesn't understand it.
many such cases!

but okay,
this doesn't explain PL.
also kind of doesn't explain OS.

OS, I could say is ignorance.
but people do know PL...

but, if OS is ignorance, it's ignorance of """design patterns""", not APIs (probably)
well, it's partially ignorance of APIs.

is it the same for PL?

okay, so. why don't people learn that they can use PLs for config and surmount these issues?

I guess, they give up too soon? and don't see how a few small additions make it work?

so that's another frame:
people give up too soon when working with existing abstractions

and that means they are reusing less complexity.

boopy says:
it's easier and more fun to write new code than to understand old code.

(or know how to change old code)

but,
it may be more complex in the long term!

but, IMO, it's actually fun to understand (high quality) old code.

and to reduce new features to it.

that's why I do it! it's enjoyable!

to reduce a problem to existing abstractions,
dissolve it entirely to nothing,
it's fun!

it's a mental workout!

now, the code archeaology stuff... that's boring, I guess.

I mean, sometimes there isn't a good introduction to the theory of an abstraction.
and you have to figure it out for yourself.

but the core part? learning a new theory?
and then reducing new work to those theories?

that's fun!

so I mean... programming as theory-building, sure,
but also, programming as theory-reusing:
using existing theories to make a new theory.

yeah...
an important part is to comprehend the theories of the existing code!

there's so much reusable code out there,
we don't need more,
we just need to understand what's already available!

programming as theory building is highly meaningful here, as always.
https://pages.cs.wisc.edu/~remzi/Naur.pdf

anyway. so.

it's fun to understand the theory of existing code.
it allows you to save lots of time.
and also it's your job.

"the difference between good programmers and bad programmers" to be dramatic.
good programmers enjoy learning the theories behind some existing abstraction.
bad programmers do not.

the reason for this classification is that a programmer who does not enjoy learning theories,
will not often do it.

if they don't do it, they won't program using those theories.
if they don't program with those theories, they'll make up new problem-specific theories,
instead of something coherent.
and that will exhaust the complexity budget.
(and exhausting the complexity budget is bad)

so maybe I should just say, "complexity-inducing programmers",
and "not-complexity-inducing programmers".

well, okay, there are other things too... like algorithmists??
and... other people who are tolerant of wading through garbage...

so maybe I shouldn't assert this is the dividing line between good and bad.

anyway, so.

don't fear existing abstractions...

because it's actually fun to learn them

thesis: "It is fun and useful to learn existing abstractions"

ummmm well.
I guess I can't say what's fun for you.
but I think it's fun and useful,
in part because it lets you push out a steady stream of surprisingly good ideas and "counterintuitive" takes.

I mean, this is my "secret technique", really.
if you learn this you will be like me.

Stop being afraid of existing code, and learn it

well, that's a bit weirdly stated.
okay so let's see. can we push this any further?

Learning an existing abstraction's theory... hmm...
well ideally it has docs that explain it, and you can get it with some tinkering,
or by looking at examples or many different explanations from different perspectives,
or by analogizing it to other code, or by having some explain it to you on a whiteboard,
or, or, or...
(worst case you have to synthesize that by exploring the code)

but then...
ok... so...
you need to be able to, I guess... question received wisdom about how the theory can be used.

that's basically all of my stuff...
looking at how the theory can be transposed or reused in unexpected places and ways.

um right so learn new abstractions rather than,
just keep programming on with your basic skill.

You're better off doing this than just trucking along with your existing programming knowledge
and writing new code every time.
*** title attempts
Use old code in strange ways

Use your theories in strange ways

Practice thinking in strange ways
(ugh now this just sounds like "think outside the box")

Reuse code in strange ways

Understand existing abstractions and apply them in new ways

Don't fear existing code (or else)

If you fear existing code, you're going to suffer

If you always fear existing code, you're going to pay the price eventually

If you always fear existing code, you're going to suffer eventually

Fearing existing code is expensive

Being afraid of existing code is expensive

If you always fear existing code, you're going to make more complex systems

Fear of existing code leads to overcomplicated new code

Fear of any existing code leads to overcomplicated new code

Always being afraid of existing code leads to overcomplicated new code

The cost of always being afraid of existing code is a more complicated system

Learn existing abstractions or pay the price in complexity

The price of not learning existing abstractions is measured in complexity

If you always build new components instead of reusing old ones, you'll be more complex
(duh...)

Understand existing abstractions, and use them in new ways (or suffer the consequences)

Don't fear existing code

Understanding existing abstractions is important and useful

Everyone fears existing code, but it's important and useful to understand it

Understand the code you have available, and use it

If you always fear existing code, you'll write overcomplicated software

ugh

Write simpler software by reusing existing code
(duh)

Stop writing new code instead of understanding existing code

Understand existing code, don't just avoid it by writing new code

Don't write new code, understand existing code

Save on your complexity budget by... reusing code

Code reuse is good actually, and if you don't do it, you'll suffer

(that one is a fun catchy title, I guess)
(let's write the first sentence and then try for the title...)
*** drafting attempt
If you learn the abstractions provided by existing code,
then you can apply them in new contexts
to reduce difficult problems to trivialities.
This is useful, important, and fun;
that should be
that should be 
**** try 1
Solving every problem by writing all-new code is fun and easy in the short term,
but if you don't make use of the abstractions implemented by existing code,
you're going to make your system more and more complex in the long term.

No-one actually writes "all-new" code, anyway.
You already use a general-purpose programming language and operating system.

The real issue is that you barely know how to use your language and OS.
The same goes for the libraries you use,
and the existing features in your application.
**** okay, try 2
Don't just coast by on basic knowledge of abstractions, learn them deeply!

Learn the abstractions you use deeply, don't just coast by on a surface understanding

Really learn the abstractions you use, don't just coast by on a surface understanding

A surface understanding of the abstractions you use will work in the short term;
you'll write a lot of new and unnecessary code,
because you don't know how to model problems deeply with the abstractions you're using,
but that code will work.
The real problem is in the long term:
All that new code is overcomplicated,
breaking your complexity budget,
because it's not meaningfully using the features of the abstractions,
but instead implements its own new abstraction.

If you're not going to learn the abstractions deeply,
please just shut up and be a code monkey,
and listen to what actually knowledgeable people say,
instead of polluating the air with your ill-informed suggestions.
**** analysis
wait but,
not everyone can learn all the abstractions deeply...

I guess I'm just saying... respect those who do?

and... drive your design with deep knowledge of abstractions?
right... right!

*Someone* needs to understand the old code, and they should be the one setting the design

The person who understands the existing code should set the design for the new code

um, sure?

but I'm talking more broadly, like, about OS and PL abstractions too...

are these really the same things?

I mean... do I expect everyone to learn all these abstractions?

should I not be a little more specific?
or... maybe I do think it's useful to learn as many abstractions deeply as possible

Learn abstractions deeply, as many as you can
(emphasis on deep)

um well I specifically think that OS and PL are important abstractions to learn.

it comes down to, code reuse is good. sometimes.

umm does it?

look, this is just my philosophy

My philosophy: Actually, code reuse is good, not bad

and a separate article "Programming languages are underused"

or... "You should use your programming language more"
or... "General purpose programming languages are the best tool for almost any problem"
they're only not the best tool if you want a more powerful language,
and even then it's not clear. (link to tfs.html)

or, maybe... General-purpose programming languages are The Right Way to solve almost any problem
maybe I should just say, solve it with the general purpose language first, before doing something else.

Maybe even two articles: against microkernels, and, against RPC IDLs.

And then maybe i can organize them on a new section of index, which is just,
Hey the general purpose programming language can do all this stuff!!!! 
Against fancy features and against specialized languages.
In defense of the general purpose programming language.
Actually it's more against, because I'm saying all these other tools are better in-language.

Write modules, not microkernels
Write 

(Rpc, serialization, IDLs, protos, etc...)
(The issue is that there's no cross language type system,
but it's a chicken and egg problem,
because as a result no one is doing things that would require a cross language type system)
Types not protos?
Programs not protos?
Plans... Passing... Parts... Projects...

But really I am saying to write libraries instead of services, too. But saying it as protos is better...

Write interfaces, not protos

Signatures? Not schemas

Write (module) signatures, not (protocol) schemas

Yes, perfect.
so:

Write modules, not microkernels
and
Write signatures, not schemas

ah perfect. now I can, later, whenever,
write a post about my philosophy that code reuse is good actually,
and that one should do it.
*** examples for myself
epoll (like stevenh was convinced to use it for event notification)
bink cancels instead of internal mass canceller
* post idea: read manuals!
  they are good!
  just read them!

  it's yo responsibility to have a toolkit that you understand
  so don't just use a tool and throw it away... I guess...

  should look up how I phrased this in that one comment on HN
** coming back much later
this is related to my point about abstraction.
it's valuable to learn the abstraction you're using! deeply!
reading manuals and learning abstractions;
both of them will help you out!
and they're related, they're both... reuse.
* post idea: abstraction inversions
  (in software engineering)

  and why I don't like them.

  and why I therefore don't like abstraction.

  since it risks building a new feature on top that is like the old feature down below!

  examples:
  interfaces for IO things (io_provider)

  maybe this will be about my interest in... reduction?

  yeah, this would be a good post.
  not about abstraction inversions, but about reduction.

<h2>Permanent project: Reduction of the complex and novel to the simple and familiar</h2>
My overarching interest is in clever ways to reuse existing abstractions,
rather than build new ones.
Put another way,
I'm interested in reducing complex, novel ideas
to simple implementations in terms of simpler, well-known ideas,
without losing any expressivity.
I find such reductions both practically beneficial and intellectually pleasing.
<p>
Of course, I'm certainly not opposed to new ideas.
I just find it especially rewarding when an interesting new idea can be reduced to something we already have,
teaching us a new and valuable technique without requiring us to invest lots of implementation effort.


more generally this is just anti-abstraction I guess.
related is, we already have too much abstraction...
also related is the technical advantages of open source: avoiding abstraction...

a good abstraction is one that will never, ever change...
** a later look
hah okay.
it's not that I don't like abstraction.
it's that I don't like not-reusing.

abstraction inversion is a sign of a lack of reuse!
of course, it's one kind of manifestation of it;
a specific bad thing that can happen.
but tbh I haven't ever seen abstraction inversion be forced on me.

I think it's just lack of reuse.
* drafting attempt
my philosophy:
learn the abstractions you're building on top of.

two are the programming language and the operating system.

I feel that one should learn them and use those abstractions when building new systems,
rather than build entirely novel abstractions using only the bare-minimum Turing-complete portion of the base system.

(hey, maybe I can even put this on index.html.
catern.com could have a top-down design, just like I favor for software...
where I describe my philosophy and two points in that philosophy,
"learn the programming language" and... "learn the operating system"??? maybe not the latter.

yeah I could have like,
here are some applications of learning and applying the abstractions available in the programming language;
you can do away with many other concepts and functions.

and... okay...
why do I care about running distributed software?
well it's a software freedom concern.

*kind of*???

I mean, it's both.
the lambda abstraction thing...
I guess that's also kind of a software freedom concern too;
I'm saying, hey, you don't need this fancy complicated software which is expensive to maintain,
what you have is good enough!

okay...

so from that point of view... both of them are just,
"reduce the cost" approaches.

so, why do I care about reusing existing abstractions?

because that reduces the cost of software which is good for software freedom, I guess.

um, well, not just that, obviously!
that's just one other benefit.

indeed, software freedom is nice just because it gives me lots of quality software!
that's what I said in freedist.html

um...
okay so...

why do I care about making software easier?
well, it's a marketable skill, lol.
and it's intellectually pleasing.

maybe I don't want to say that on index.html tho, heh.

maybe, though. if I can get it short enough...

it's nice to provide constructive proof of my techniques.

um, so, is this really a technique that I've been using forever?
or is it just a adaptation to the proprietary environment of TS?
I mean, what was my motivation for daemon engines?

well, I think obviously I liked daemon engines because,
I reduced a complicated problem to a set of a few known composable components.
which was pleasing.

so, yeah, reduction of problems and reuse of existing things,
that's what I like.

Reduce, reuse, reap the rewards.

(instead of "Reduce, reuse, recycle")


Reduce, reuse, save cycles

Reduce, reuse, repeat

Reduce, reuse, re-something

The last r-word should be something tech-related.

Reduce, reuse, relax

reload?
revolution? revolt?

rhyme

okay well anyway. let's actually write the article

reduce, reuse, write the program!??
* real drafting attempt
I think it's important and useful to learn abstractions deeply.

Then when you encounter a new problem,
you can reduce the problem into a problem that is solvable by those abstractions,
and reuse the existing implementation of those abstractions.
("Reduce, reuse, relax", one might say)

Two of the most useful abstractions to learn deeply are programming languages and operating systems.
Both of them are powerful and long-lived.

Then, to solve a problem,
just think a lot.
And eventually you'll reduce it to an existing solution.

one could argue there's lower abstractions - hardare, etc.
but these are the lowest open source ones,
and therefore the lowest ones that it's wise to build your career on.

ahhh... blahh...

title: Learn existing abstractions and contort your problems to fit

i mean, I do think it's best to contort to try and fit existing abstractions, since you usually can.

but maybe that's also sacrificing full understanding?

It's more important to reuse an existing abstraction than it is to faithfully solve a problem.

title: Reusing abstractions is the most important thing in programming

or...

title: Code reuse is the most important thing in programming

title: Code reuse will (do good thing)

NIH syndrome

reinventing the wheel

I mean, what's the distinction?
** when do I think code reuse is bad and when is it good?
well if the code is bad, don't reuse it
if it's good, reuse it.

things that make it bad: obscurity, not-being-old, being proprietary.

basically...
the first step,
and the only step,
should always be:
how do I reduce this to existing abstractions?
* draft again
The only step in programming is: How do I reduce this problem to existing abstractions?

just keep thinking about that repeatedly.

reducing the problem more is better.

The universal tool in programming: "Reduce the problem to existing abstractions"

My only tool for programming is: reduction

Reduction...

Reduce the problem to existing abstractions

At all times, focus on reducing the problem to existing abstractions.

I have exactly one programming trick: Reduce the problem to existing abstractions

The only programming trick you need: Reduce the problem to existing abstractions

To solve any problem, reduce the problem to existing abstractions

The universal problem solving trick: Reduce the problem to existing abstractions

Code reuse is the most important thing in computer science

Code reuse is not only good, it's the only good thing

The universal programming strategy: Reduce, reuse, relax

(
relax can mean, don't worry about how you haven't exactly solved the problem as you originally understood it.
the problem usually doesn't need to be solved in that form.
it's better to save complexity than to solve the problem exactly.
)

The universal programming trick: Reduce, reuse, relax

ah but it doesn't explain it in the title, I think I can concisely explain it.

Don't just reuse code, reuse abstractions

Reduce the problem to one you know, reuse an existing solution, and relax 

UM that's really really not what I mean though.
reusing an existing solution is counter to my point.

that's code reuse.
that's program reuse.

better, is *abstraction* reuse.

The most important thing in practical programming is abstraction reuse

The most important trick in computer science is reusing abstractions

The most important trick in computer science is to reuse abstractions

Reusing abstractions is the most important trick in computer science

To design a program, first look at how you can reuse existing abstractions

To solve a problem, first look at how you can reuse existing abstractions

To solve a problem, look at how you can reuse existing abstractions

To solve a problem, reuse existing abstractions

To solve a problem, reuse existing abstractions

To solve a problem, reuse what already exists

Reuse is the most important trick in computer science

no, no, but not existing solutions

like, it's key that you learn some good abstractions, and then use them heavily

Learn high-quality abstractions, and then reuse them heavily

hm but this sounds like forcing things through unsuited abstractions just because you know them

Use the right abstraction for the job

um yeah sure but this doesn't say anything about reuse

Learn the right abstraction for the job

hmm better...

Learn the right abstraction for the job

Find the right pre-existing abstraction for the job

um but that sucks...

Use low-level abstractions

i mean I guess that's one point I have...

Don't reuse high-level code, reuse low-level abstractions

umm..

title: The key to programming is reusing the right abstraction

I guess - this ties into believing there are no novel ideas?
like if you try to come up with something new,
you'll make something bad?
everything old is new again?
so read the literature and use what's already there? hmm...
* keep notes
Nothing is new, use old solutions.

Solve your problems starting from the dawn of history

Solve your problems in the lowest-level possible way

Solve problems by starting at the bottom of the abstraction stack

(That's yet another description of my strategy I guess...)

Solve problems with as few layers of abstraction as possible

(Yet another alternative framing...)

Add as little abstraction as possible when solving problems

(The idea being... The big abstractions people use like VMs or whatever, are unnecessary, the base abstractions we have are sufficient)

You already have enough abstraction

You probably already have enough abstraction

We keep piling up abstractions, use the existing ones instead of adding more

Use existing abstractions instead of adding even more

Use (and improve) existing abstractions instead of adding more

Reuse is the most important programmer skill

Knowing when and what to reuse is the most important programmer skill

Appropriate reuse is the most important programmer skill

Programming is 100% code reuse

(Because I want them focused on how they can most effectively reuse existing code...)

Programming is 100% code reuse and always has been

(I say this because we're veering into, ugh we're just gluing stuff together, programming sucks now, territory)

All of programming is reuse

(No it's not)

The most important part of programming is code reuse

Code reuse is good and important and fun

Please, just think about how you could implement this without writing too much code

Please, just think about how you could implement this without adding new abstractions

Learn existing abstractions

Spend more time on reduction

The key to programming is solving new problems with existing abstractions

The key to programming is solving new problems with existing abstractions

I approach problems by trying to reduce them to abstractions I already know

The key to programming is reducing new problems to trivial programs on top of existing abstractions


title: Reduce new problems to trivial programs on top of existing abstractions

Stop writing non-trivial programs, but also stop making new abstractions to make things trivial.

Don't instead:
1. write a complicated program
2. write a new abstraction and a trivial program
3. 


title: The goal of programming is to write trivial programs on top of existing abstractions

title: Don't write complex programs, don't write new abstractions

title: Write simple programs on top of existing abstractions

title: Find simple solutions that use existing abstractions

title: My primary ethos: Find simple solutions that use existing abstractions

title: My trick: Find simple solutions that use existing abstractions

Use existing abstractions to find simple solutions

Use existing abstractions to find simple solutions

Find simple solutions by using existing abstractions

(it's simple in terms of the whole complexity of the system)

Find simpler solutions by using existing abstractions


- read the manual
- reuse existing abstractions
- don't write new abstractions
- don't write new complicated ones


Code reuse is good and people don't spend enough time on it

yeah, let's just say that. fine!

except that's not strong enough, and also implies something different...

actually, I don't know that it does.

"Code reuse" is something that I dislike, because I don't want to write new abstractions;
instead I want to really heavily use the existing abstractions.

Reusing existing code is good and people don't spend enough time on it

Reusing existing code is the most important programmer skill

okay, that feels good.

(except now the concern would be that, this would trigger "programming sucks now" stuff.
but we can caveat that in the article)

mm.

title: Finding new applications for existing code is the most important programmer skill

maybe, maybe.

but, okay, maybe we can open with...

something informal.
* draft
title: Reusing existing code is the most important programmer skill

Wait, wait, isn't code reuse an antipattern?
Doesn't the author of this article know about all the ways code reuse can go wrong?
And how people design with excessive amounts of abstraction,
because they're trying to support code reuse?
And lately, the whole field of programming has been increasingly reduced to mindless glue work,
just plugging together existing things,
in an untterly uninspired way;
surely the author doesn't think mindless glue work is the most important programmer skill?

That's all true, but...
nevertheless, for me, my most successful and interesting programming accomplishments
have been finding new and clever ways to reuse existing abstractions.
And I think more programmers should think hard about how they can reuse existing abstractions!

We might make a (somewhat arbitrary) distinction between reusing *code*,
and reusing *abstractions*.
Reusing code gives us little - it's just code, we can write it ourselves.
But each abstraction in your environment is another added complexity;
to reuse an existing abstraction, then, is to avoid adding more complexity.

And we might also distinguish *writing for reuse*,
from actually *performing reuse*.
Writing for reuse is usually bad - mainly because writing a bunch of code is easy,
but writing a really good abstraction is extremely hard.

And, of course, we probably should reuse *good* code,
not *bad* code.

If you focus on finding good existing abstractions,
and trying to turn each new problem into a trivial program on top of those good existing abstractions...
you'll be successful at minimizing complexity while solving problems, at least in my experience.

Some attributes that suggest an existing abstractions is good:
- Widely used
- Old (like 30 years)
- Open source

Some attributes that suggest an existing abstraction is bad:
- Used by only a small group
- New (like 10 years)
- Proprietary, or otherwise internal to a company

"Widely used", "old" and "open source" all, as it happens,
apply to some of the most important low-level abstractions,
like Linux and most programming languages.
Those are some good abstractions which have been extremely successful.

You should learn those abstractions,
because if you don't,
you'll recreate them.
(Or, possibly, use some else's worse recreation of those abstractions)

Often some people talk about how low-level abstractions are important to learn
for debugging issues and understanding the system;
others counter that low-level abstractions just serve as a form of gatekeeping,
and that it's good to work purely in terms of the top of the abstractive tower.

They're both wrong:
Those low-level abstractions are useful because they provide high-quality abstractions
with lots of features,
and if you don't know about them, you'll spend your complexity budget on recreating them.
They might have some utility for debugging, but that's a minor use;
the real advantage is in actually using them to solve problems.
And it's true that computing has advanced by adding layers and layers of abstraction,
but at some point you need to actually use those abstractions,
not just build new ones on top.

But,
this also applies to less low-level abstractions.

If there's a core of stable operations provide by some service you use,
learn them!
Use them!

If there's some tool you like and use heavily,
read its manual.

All of my interesting programming accomplishments have come because
I knew some high-quality abstraction deeply and came up with some new use for it.
* low level abstractions
some people talking about whether it's valuable for engineers to know low level abstractions;
mostly for the sake of debugging.

but, I say, it's useful because otherwise they'll create new abstractions which duplicate those!
they won't know to reuse them!

like, learning these things, okay there was talk of gatekeeping, but...
if people don't know the fundamental abstractions, they'll recreate them endlessly.

If you don't learn existing abstractions, your software will be overly complex

* "layered abstractions are good" says some
#+begin_quote
Less facetiously: the history of progress in most domains, and
especially computing, is in part a process of building atop successive
layers of abstraction to increase productivity and unlock new
value. Anyone who doesn't see this really hasn't been paying
attention.
#+end_quote

yes, but you need to actually use those abstractions!
not just build a new abstraction layer every time you need a "new" feature;
those features may exist in the abstraction layer below!
* maybe frame it as my advantage?
My advantage is that I have learn existing abstractions enough to reuse them,
instead of recreate them ignorantly.

wait, wait, okay.
it's not code, it's abstractions.
maybe I should say that.

title: Reusing existing abstractions is the most important programmer skill

cuz I don't really care about the code, just the abstraction.
(kind of a weird division but whatever)

and, it's really very personal.
ummm my train of thought was just disturbed by boopy...

abstractions, abstractions, don't care about the code, just the abstraction...

ummmm

and I was thinking about putting it in the life section...

oh and it can be more general than code.
oh! it was relating to those number theory tweets I read.
https://twitter.com/benskuhn/status/1419281153983500290

right like, that's fine.
understanding the abstraction of the results is what I'm promoting;
not understanding the code behind them.

right so it's just a general,
"Learn existing abstractions (but don't bother with their code)"

(I guess?)

right, right.
so like the dives into the implementation of malloc or the shell or operating systems:
not really too necessary.
(well, it's necessary to make you autonomous, but it's not what I'm promoting here)

the detailed study of the abstraction though:
that's good.

title: Learn your tools well, so you can use them

that would tie into something else I frequently say,
which is to read manuals and learn tools deeply.

it's not just tools though... it's also the APIs and software you already have...
but mostly those aren't tools?
well, I guess my point would be to write tools, not big applications.

and to see when an application you have, is actually a tool.

although! it's not just "learn your tools",
it's also, "learn abstractions down the stack from your tools".

so... it's more like...

learn your *available* tools well, so you can use them.

right.

Learn the available tools well, so you can use them

not just the ones you immediately know and use,
but also other ones available like the OS and PL.

But...

I guess I'm suggesting that one should focus on "good" tools, not just the available ones.

Learn good tools well, so you can use them

um, I guess "available" is contained within "good"?

and... I guess if I send this to someone about software, heh,
part of my point is like, hey this is why I prefer open source and stuff,
because that raises the goodness, and so I can learn them well, so then I can use them.

shorten it:

title: Learn good tools

but that's obvious AGAIN. 
everyone says pick good tools,
and everyone says learn them.
there are articles out there (like gwern's) about how to pick good tools.

(I should probably link
https://www.gwern.net/Choosing-Software
in this post)

the real point is more in the direction of...
actually applying those tools? no that's dumb. uh...

if you choose good software,
and then you learn it well,
you'll be able to do things in a much less complex way

title: Choose good tools, learn them well, and you'll have less complexity

except, why will you have less complexity?

if you choose good software,
and then you learn it well,
you'll be able to use it to solve many problems,
without having to add complexity by adding new software (either adopting it or writing it yourself)

um, okay, duh.

but I guess the point is bidirectional:

you should choose good software and learn it because it will give you this benefit.

and,
if you want this benefit (i.e., you're trying to solve a problem with minimal complexity),
you should look for good software and learn it.

that's not exactly bidirectional.
jmaybe I should say it from the benefit first.

title: If you want to solve a problem simply, look for good existing abstractions

oooh I like that one.
it encapsulates my philosophy well, actually.

OK.
I definitely like starting with:
"If you want to solve a problem simply",
or at least "If [x]".
I just need to polish the "then Y" part,
maybe.

it's not just "look for".
it's "look at".
it's "use".

title: If you want to solve a problem simply, reuse existing abstractions

yeah, okay.

that's good, better than "most important programmer skill".
and it's generic, too.

* draft
title: If you want to solve a problem simply, reuse existing abstractions

If you want to solve a problem simply, look at the existing abstractions you have available,
and reduce the problem to a trivial program using one or more of those abstractions.

In this way, you can minimize the additional complexity spent on the problem;
instead, you reuse the complexity already invested in the existing abstractions.

If you know more about an abstraction,
you're more likely to be able to solve a problem in terms of that abstraction.
While working on a problem, or while preparing for future problems,
try to learn abstractions that seem likely to help.

[[https://www.gwern.net/Choosing-Software][Choose]] abstractions that are likely to continue being maintained;
ones that are old, widely used, and open source.
Such abstractions also tend to be higher quality.

The history of computing has been a history of layering new abstractions on top of old ones.
This has, at least, not stopped forward progress;
but still, at some point you need to actually need to use the abstractions you've created,
rather than endlessly build more.

Think a lot before you create a new abstraction.
You don't need to, and probably shouldn't,
build a new reusable abstraction if you're just solving one problem;
just write a program to solve that one problem.
If you do feel that you need to create a new abstraction,
try to create as little novelty as possible.
It is hard to create good abstractions,
so you should do it as little as possible.

Remember that you can change your problem to fit existing abstractions.
It's more important to save complexity
than it is to faithfully solve a problem,
because sacrificing simplicity to obtain a solution
will lose both solution and simplicity in the end.

For an example of these principles in action,
see [[http://catern.com][almost anything I've written or done]].
Some abstractions that I particularly like to use are
general-purpose programming language (such as functions)
and the Linux syscall API.

This principle is the absolute core of all my thinking about programming,
and inasmuch as I've done anything novel,
I credit this principle for leading me to good ideas.

