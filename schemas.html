<html>
  <head>
<title>Write (module) signatures, not (protocol) schemas</title>
</head>
<body>
<h1>Write (module) signatures, not (protocol) schemas</h1>
If you write a library, you'll have simpler code than if you write a standalone server,
because
type signatures (which describe libraries, modules and other importable pieces of code)
are substantially more expressive than protocol schemas
(which describe protocols for communicating with servers).
<p>
For example,
a function pointer is a valid argument or return type for a function in most languages, even in C.
But almost no protocol schemas support this.
In more advanced languages,
objects, interfaces, abstract data types, types themselves, type constructors,
references to other modules, and many other constructs
are valid arguments and return types.
You can't express any of that in protocol schemas;
this makes many tasks more complicated.
<p>
So why do people ever write servers instead of libraries?
<p>
A library can do anything that a standalone server can do.
But our modern Unix-derived programming environments are slanted towards standalone servers,
so some things are easier with standalone servers;
hence, servers are almost always the first choice.
<p>
Nevertheless, contrary to popular belief, libraries can do anything, including:
<ul>
  <li>Maintain stable, backwards-compatible interfaces
    <p>
    The precise details of how to maintain a backwards-compatible signature is language-specific,
    but it's possible in most languages.
    For example, don't add a new mandatory argument to an existing function;
    instead, add an optional argument with a default.
    <p>
    In fact, a library is strictly more powerful than a protocol schema in this regard:
    If you really wanted to,
    you could use a protocol schema directly to define the format of the data passed in and out of the library.
  <li>Be updated without restarting the process using them.
    <p>
    This field of techniques is called
    <a href="https://en.wikipedia.org/wiki/Dynamic_software_updating">dynamic software updating</a>.
    These techniques are actually quite easy
    if the library only does things that one could do over a protocol schema.
    If the library uses more than that bare minimum of features,
    dynamic software updating becomes harder, but still possible.
    <p>
    One interesting use of this ability is to implement
    extremely high-performance, but backwards-incompatible,
    <a href="http://catern.com/mobilelibs.html">wire protocols</a>.
  <li>Be used from, or implemented by, programs written in multiple languages
    <p>
    The most common way to support cross-language interaction in libraries is to go through the C type system;
    C functions can be called from, or implemented in, any language with a C FFI.
    Going through the C type system can be constraining,
    so
    <a href="https://github.com/tweag/inline-java">there</a>
    <a href="https://github.com/tweag/HaskellR">are</a>
    <a href="https://github.com/PyO3/pyo3">many</a>
    <a href="https://jpype.readthedocs.io/en/latest/">projects</a>
    which allow one language to call functions in another language without going through C.
    This also allows a signature in one language
    to have multiple implementations in other languages.
    <!-- 
it's important to note that the fundamental difficulty here isn't converting calling conventions,
or figuring out how to read datastructures in one language from another,
or things like that.

those things are difficult, true, but they aren't fundamental;
the fundamental difficulty is converting between the type systems of the two languages.
there's no equivalent of a char* in most languages - it's something that's simply not expressible;
so you need some kind of conversion from the interface in the using-language,
and the interface in the implementing-language.

almost always, that's hand-coded (or expressed with some DSL or annotations),
but one opportunity that seems under-explored is generating the implementing-language interface,
from the using-language interface;
that seems like it could save some hand-coding,
even though it's not fundamentally better.

that's how schema languages work:
the using-language is the schema language, which has no support for writing actual values/terms, only types,
so all the adaption work necessarily has to be done in the implementing-language.
this is usually diffuse

for libraries/signatures,
the hand-coding required to make the using-language interface compatible with the implementing-language interface
is most commonly done in the using-language.
The using-language is usually able to call into 
some auto-generated using-language version of the implementing-language interface,
but such calls require special manipulations and special types;
to create a real using-language interface, then, an adapter is hand-coded.

compare this to the situation with schemas;
from the schema, a client is generated in the using-language.
this client is often pretty high-quality, when compared to the situation with libraries;
but it still usually needs hand-coded adapter code
(which is often diffused throughout the program rather than centralized)

compare also to the situation with custom network protocols that aren't described by a schema.
there, you might try to model the network protocol with some helper library,
but ultimately you probably will have to do a great deal of work by hand
in both the using-language and implementing-language.

this all raises the question:
why do schemas generate better clients and servers than library


this is similar to implementing a custom network protocol by hand (or with some simple utilities).
a custom network protocol doesn't


  -->
    <!-- 
worst case, just write the adapter from Haskell interface to Java and R manually,
yeah... I guess it's a question of whether you write the adapter code in Haskell,
or in the implementation language. hmm...
hey, with schemas, you can't write an "adapter" in the schema language itself.

so...

 -->
    <!-- 
hmmmmmmmm
HMMMMMMMMMMMMMMMMMMM

haskell calling Java...
something something...
if we can call the Java or whatever...
we can pass functions...

which means we can implement a library.

but...

if I have some Haskell interface, and I want to implement that with another library...
oh! I can just manually write it!

 -->

      
    <!--
     !--   This is often used to have a single library which is wrapped in many languages,
     !--   but you can also use it to have a single 
     !-- 
     !--   This is straightforward if the signature of the library is available as C headers;
     !--   either by directly defining it as C headers or by generating C headers from a type signature in an arbitrary language
     !--   as <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">JNI</a> does.
     !--   Such a signature can be implemented in any language with a C FFI.
     !--   You could also use 
     !-- You can also define the type signature in a higher-level language,
     !-- generate C headers from that high-level description,
     !-- and then implement those headers (or other signatures).
     !-- 
     !-- works like that; it reads Java type signatures and generates implementable C headers with function declarations.
      -->
    <!--
I don't actually know of anything doing such "reverse SWIG" generation, though...
that would be really helpful actually.
That could serve as the foundation of a good cross-language type system...
in .NET maybe?
ah, java does this.
https://typedefs.com/ is interesting
 -->
  <li>Run in parallel, using multiple cores.
    <p>
    Obviously: You can run library functions on multiple threads.
    Different threads can even have different IO and CPU priority levels.
  <li>Be built separately from the rest of the program, and have different dependencies.
    <p>
      For example,
      by <a href="https://softwareengineering.stackexchange.com/questions/297276/what-is-a-shaded-java-dependency">"shading" dependencies</a> in Java,
      or with linker scripts, <a href="https://man7.org/linux/man-pages/man3/dlopen.3.html">dlmopen</a>
      or <a href="https://github.com/NVIDIA/libglvnd">DT_FILTER</a> in C.
    <p>
  <li>Isolate failures.
    <p>
      "<a href="https://cs155.stanford.edu/papers/sfi.pdf">Software fault isolation</a>"
      is all about this;
      SFI allows a library to be run in the same address space
      without the ability to interfere with other memory in that address space.
      Other techniques in this vein are used all the time for emulation and virtualization.
    <p>
  <li>Access resources on other hosts and in other environments.
    <p>
      <ul>
        <li>In general, there's no reason a library can't spin up a stub in some environment,
          and use that to access resources in that environment, including on remote hosts.
          I have a <a href="./constructive.html">constructive proof</a> of this:
          <a href="https://github.com/catern/rsyscall">rsyscall</a>.
        <li><a href="./list_singledist.html">Distributed languages</a>
          (including libraries that make existing languages into distributed lanaguages)
          let you write libraries which access remote resources.
        <li><a href="./supervisors.html">Process supervisors</a> can be replaced with a library.
      </ul>
    <p>
  <li>Have access to resources that the rest of the program isn't allowed to access.
    <p>
    For example:
    <ul>
      <li>Javascript running in a browser can access functionality provided by the browser as a library;
        the browser and the Javascript are running at different privilege levels.
      <li>An object in a type-safe language can contain
        <a href="https://en.wikipedia.org/wiki/Object-capability_model">capabilities</a>
        for resources which it uses to implement its methods,
        without those capabilities being available to the code calling those methods.
      <li>Java-style
        <a href="https://cs.stackexchange.com/questions/796/how-does-stack-inspection-work">stack inspection</a>
        can restrict user or library code to deny access at runtime to unauthorized methods.
        <!-- good paper about stack inspection: 
             https://www.usenix.org/legacy/publications/library/proceedings/usits97/full_papers/gong/gong.pdf -->
      <li><a href="https://en.wikipedia.org/wiki/Capability-based_addressing">Capability-safe architectures</a>
        such as
        <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a>
        prevent code from accessing memory that it doesn't have an explicit capability for.
      <li><a href="https://cs155.stanford.edu/papers/sfi.pdf">Software fault isolation</a>
        can allow
        <a href="http://www.cs.unc.edu/~dewan/242/f96/notes/prot/node11.html">Multics-style "call gates"</a>,
        where a library has a different privilege level from other code.
    </ul>
    <p>
      You might be concerned about using such fancy techniques. Sometimes, they aren't necessary,
      because the whole program can safely be given access to the supposedly-privileged resource,
      perhaps because the resource is one more of:
    <ul>
      <li>fast to create (so we can just create them on the fly in the library)
      <li>cheap to create (so we can give every user their own)
      <li>already multiplexed and safe to share
        (it's amazing how easy it is to miss this if you don't explicitly think about it)
      <li>easily tweaked to be shareable (for example, a resource could be leased out to a user then reset when they're done)
      <li>or otherwise safe or can be made safe to give to users directly
    </ul>
    <p>
    Consider this carefully; this point is often non-obvious.
    <p>
</ul>
<!--
 !-- One issue is that C is the standard way to write language-independent type signatures,
 !-- even for libraries not written in C.
 !-- That means that if you want to write a language-independent library,
 !-- your type signature can only use features present in the C type system.
 !-- The C type sysem is more expressive than protocol schemas,
 !-- but pales in comparison to more advanced modern languages with objects or abstract data types,
 !-- so it may seem irrelevant to pick between C and protocol schemas.
 !-- A more powerful language-independent type system would be really useful...
  -->
<!-- hmm well, also protocol schemas are nicer in many ways...
     variable sized data, etc...
     which would imply they're superior for language-independent libraries...
 -->
</body>
</html>
