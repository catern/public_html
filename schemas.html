<html>
  <head>
<title>Write (module) signatures, not (protocol) schemas</title>
</head>
<body>
<h1>Write (module) signatures, not (protocol) schemas</h1>
If you write a library, you'll have simpler code than if you write a standalone server,
because
type signatures (which describe libraries, modules and other importable pieces of code)
are substantially more expressive than protocol schemas
(which describe protocols for communicating with servers).
<p>
For example,
a function pointer is a valid argument or return type for a function in most languages, even in C.
But almost no protocol schemas support this.
In more advanced languages,
objects, abstract data types, references to other modules, and many other constructs
are valid arguments and return types.
You can't express any of that in protocol schemas;
this makes many tasks more complicated.
<p>
So why do people ever write servers instead of libraries?
<p>
A library can do anything that a standalone server can do.
But it can require more expertise to do many things with libraries,
since our modern Unix-derived programming environments
are heavily slanted towards standalone servers.
Hence, servers are often the first choice.
<p>
Nevertheless, contrary to popular belief, libraries can:
<ul>
  <li>Maintain stable, backwards-compatible interfaces, both API and ABI.
    <p>
    Most people know how to do this at the API level.
    For example, they know to not add new mandatory arguments to an existing function,
    and instead to only add optional arguments with defaults.
    Backwards compatibility can be a bit trickier at the ABI level,
    but still possible,
    especially in more advanced languages than C,
    and in the many situations where ABI stability doesn't actually matter.
    <p>
    In fact, a library is strictly more powerful than a protocol schema in this regard:
    If you really wanted to,
    you could use a protocol schema directly to define the format of the data passed in and out of the library.
  <li>Be updated without restarting the process using them.
    <p>
    This field of techniques is called
    <a href="https://en.wikipedia.org/wiki/Dynamic_software_updating">dynamic software updating</a>.
    These techniques are actually quite easy
    if the library only does things that one could do over a protocol schema.
    If the library uses more than that bare minimum of features,
    dynamic software updating becomes harder, but still possible.
    <p>
    One interesting use of this ability is to implement
    extremely high-performance, but backwards-incompatible,
    <a href="http://catern.com/mobilelibs.html">wire protocols</a>.
  <li>Run in parallel, using multiple cores.
    <p>
    Obviously: You can run library functions on multiple threads.
    Different threads can even have different IO and CPU priority levels.
  <li>Be built separately from the rest of the program, and have different dependencies.
    <p>
      For example,
      by <a href="https://softwareengineering.stackexchange.com/questions/297276/what-is-a-shaded-java-dependency">"shading" dependencies</a> in Java,
      or with linker scripts, <a href="https://man7.org/linux/man-pages/man3/dlopen.3.html">dlmopen</a>
      or <a href="https://github.com/NVIDIA/libglvnd">DT_FILTER</a> in C.
    <p>
  <li>Isolate failures.
    <p>
      "<a href="https://research.google/pubs/pub35649/">Software fault isolation</a>"
      is all about this;
      SFI allows a library to be run in the same address space
      without the ability to interfere with other memory in that address space.
      Other techniques in this vein are used all time for emulation and virtualization.
    <p>
  <li>Access resources on other hosts and in other environments.
    <p>
      <ul>
        <li>In general, there's no reason a library can't spin up a stub in some environment,
          and use that to access resources in that environment, including on remote hosts.
          I have a <a href="./constructive.html">constructive proof</a> of this:
          <a href="https://github.com/catern/rsyscall">rsyscall</a>.
        <li><a href="./list_singledist.html">Distributed languages</a>
          (including libraries that make existing languages into distributed lanaguages)
          let you write libraries which access remote resources.
        <li><a href="./supervisors.html">Process supervisors</a> can be replaced with a library.
      </ul>
    <p>
  <li>Have access to resources that the rest of the program isn't allowed to access.
    <p>
    For example:
    <ul>
      <li>Javascript running in a browser can access functionality provided by the browser as a library;
        the browser and the Javascript are running at different privilege levels.
      <li>An object in a type-safe language can contain
        <a href="https://en.wikipedia.org/wiki/Object-capability_model">capabilities</a>
        for resources which it uses to implement its methods,
        without those capabilities being available to the code calling those methods.
      <li>Java-style
        <a href="https://cs.stackexchange.com/questions/796/how-does-stack-inspection-work">stack inspection</a>
        can restrict user or library code to deny access at runtime to unauthorized methods.
        <!-- good paper about stack inspection: 
             https://www.usenix.org/legacy/publications/library/proceedings/usits97/full_papers/gong/gong.pdf -->
      <li><a href="https://en.wikipedia.org/wiki/Capability-based_addressing">Capability-safe architectures</a>
        such as
        <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a>
        prevent code from accessing memory that it doesn't have an explicit capability for.
      <li><a href="https://research.google/pubs/pub35649/">Software fault isolation</a>
        can allow
        <a href="http://www.cs.unc.edu/~dewan/242/f96/notes/prot/node11.html">Multics-style "call gates"</a>,
        where a library has a different privilege level from other code.
    </ul>
    <p>
      You might be concerned about using such fancy techniques. Sometimes, they aren't necessary,
      because the whole program can safely be given access to the supposedly-privileged resource,
      perhaps because the resource is one more of:
    <ul>
      <li>fast to create (so we can just create them on the fly in the library)
      <li>cheap to create (so we can give every user their own)
      <li>already multiplexed and safe to share
        (it's amazing how easy it is to miss this if you don't explicitly think about it)
      <li>easily tweaked to be shareable (for example, a resource could be leased out to a user then reset when they're done)
      <li>or otherwise safe or can be made safe to give to users directly
    </ul>
    <p>
    Consider this carefully; this point is often non-obvious.
    <p>
</ul>
<!--
 !-- One issue is that C is the standard way to write language-independent type signatures,
 !-- even for libraries not written in C.
 !-- That means that if you want to write a language-independent library,
 !-- your type signature can only use features present in the C type system.
 !-- The C type sysem is more expressive than protocol schemas,
 !-- but pales in comparison to more advanced modern languages with objects or abstract data types,
 !-- so it may seem irrelevant to pick between C and protocol schemas.
 !-- A more powerful language-independent type system would be really useful...
  -->
<!-- hmm well, also protocol schemas are nicer in many ways...
     variable sized data, etc...
     which would imply they're superior for language-independent libraries...
 -->
</body>
</html>
