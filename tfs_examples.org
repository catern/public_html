#+title: Write code, not compilers
#+HTML_HEAD: <style type="text/css">pre.src {background-color: #303030; color: #ffffff;} body{ max-width:70em; margin-left:auto; margin-right:auto; }</style>

* Explanation
To convert a function into some other type
(executable code, or a pretty-printed string, or something else),
the easiest way is to call the function,
passing certain arguments,
such that the desired type is returned from the function.

A function does not need to be parsed and statically analyzed to figure out what it does.
The function itself will tell you: Just call it and see.

The function will speak to you in a language determined by the arguments you pass it.

- If you pass it objects and methods which perform IO and return unit,
  it will speak to you in the language of side-effects.
- If you pass it objects and methods which pretty-print their arguments and return a string,
  it will speak to you in the language of pretty-printed programs.
- If you pass it objects and methods which allocate registers and return instructions,
  it will speak to you in the language of executable code.

The fewer global variables and types that a function refers to,
the more the function can speak in the language we desire,
rather than a hard-coded predetermined langauge.
* Examples
That koan alone may not bring you to enlightment,
so here's some examples
in working, type-annotated Python 3.
** The interface and program
First, an interface:
#+begin_src python
class Data:
    "Some opaque piece of data"
    pass

class Directory:
    "A directory, in which we can create files"
    def create_file(self, name: str) -> File: ...

class File:
    "A file, to which we can append several types of values"
    def append_str (self, data: str ) -> None: ...
    def append_data(self, data: Data) -> None: ...
    def append_path(self, data: File) -> None: ...
#+end_src

And a short program that uses that interface:
#+begin_src python
def create_file_with_contents(dir: Directory, name: str, arg: Data) -> File:
    "A helper function to create a file containing some data"
    file = dir.create_file(name)
    file.append_data(arg)
    return file

def prog(dir: Directory, arg1: Data, arg2: Data) -> File:
    "A simple program manipulating files and directories"
    paths = dir.create_file("paths")
    arg1_file = create_file_with_contents(dir, "arg1", arg1)
    paths.append_str("arg1 file path:")
    paths.append_path(arg1_file)
    arg2_file = create_file_with_contents(dir, "arg2", arg2)
    paths.append_str("arg2 file path:")
    paths.append_path(arg2_file)
    return paths
#+end_src

By passing different implementations of the interfaces to this program,
we will reinterpret the program
as doing different things and producing different results.
** IO
First, the obvious implementation:
One which just writes to the filesystem.

#+begin_src python
@dataclass
class StrData(Data):
    "Some data, specifically a string"
    content: str

    def serialize(self) -> str:
        return self.content

@dataclass
class IODirectory(Directory):
    "A directory in the filesystem, in which we'll create files"
    path: str

    def create_file(self, name: str, size: int=None) -> IOFile:
        """Open and create a file in this directory in the filesystem

        An optional argument, size, will preallocate space in the file
        for future writes. We'll use this later.

        """
        path = self.path + "/" + name
        f = open(path, 'w')
        if size:
            f.truncate(size)
        return IOFile(path, f)

@dataclass
class IOFile(File):
    "A file in the filesystem, to which we'll write"
    path: str
    file: t.TextIO

    def append_str(self, data: str) -> None:
        self.file.write(data)

    def append_data(self, data: StrData) -> None:
        self.file.write(data.content)

    def append_path(self, data: IOFile) -> None:
        self.file.write(data.path)
#+end_src

We can then run =prog= with this implementation,
to get the expected behavior of making some files and writing into them.

#+begin_src python
def main():
    dir = IODirectory("/tmp/somedir")
    arg1 = StrData("my very cool and neat data")
    arg2 = StrData("some other kind of cool and neat data")
    prog(dir, arg1, arg2)
#+end_src

So far, this is all completely conventional.

** Testing
We can pass an implementation which transforms our program into a test.
At each point, instead of performing an operation,
the program asserts that the operation has been performed correctly.

That's what the Test implementation does:
- Instead of creating a new file,
  we assert that the file is there.
- Instead of writing to the file,
  we read the file and assert its contents match our expectation.

This isn't a mock; it really does do IO in the filesystem,
just different IO.

#+begin_src python
@dataclass
class TestDirectory(Directory):
    "A directory in the filesystem, in which we'll open files"
    path: str

    def create_file(self, name: str) -> TestFile:
        """Open a file in this directory in the filesystem

        If the file doesn't exist, we'll throw an exception.

        """
        path = self.path + "/" + name
        # throws if the file doesn't exist
        f = open(path, 'r')
        return TestFile(path, f)

@dataclass
class TestFile(File):
    "A file in the filesystem, which we'll read from"
    path: str
    file: t.TextIO

    def append_str(self, data: str) -> None:
        """Assert this string matches the data in this file.

        As we read more data from the file, our position in the file
        moves forward and we read new data.

        """
        read_data = self.file.read(len(data))
        if data != read_data:
            raise Exception("the next data in the file should be", data, "not", read_data)

    def append_data(self, data: StrData) -> None:
        self.append_str(data.content)

    def append_path(self, data: TestFile) -> None:
        self.append_str(data.path)
#+end_src

Now we can test the results of the IO implementation by running the Test implementation.

#+begin_src python
def testmain():
    dir = IODirectory("/tmp/somedir")
    arg1 = StrData("my very cool and neat data")
    arg2 = StrData("some other kind of cool and neat data")
    # run with IO
    prog(dir, arg1, arg2)
    # run with Test
    prog(TestDirectory(dir.path), arg1, arg2)
#+end_src

First we run =prog= once with IODirectory to create the files.
Then we run =prog= with TestDirectory to check that the files are there,
and have the correct contents.

** Pretty printing
This implementation of =Data=, =Directory=, and =File= pretty-prints the program that they are passed to.

Whenever a method is called,
this implementation writes a line of code which calls that method.
Variable names are generated to store any returned values,
and used when later method calls are made with those values.

#+begin_src python
@dataclass
class PPDirectory(Directory):
    program: t.List[str]
    variable_name: str

    def create_file(self, name: str) -> PPFile:
        "Write a line of code to create a file and store it in an arbitrarily named variable"
        file = PPFile(self.program, f"file{len(self.program)}")
        self.program.append(f"{file.variable_name} = {self.variable_name}.create_file('{name}')")
        return file

@dataclass
class PPFile(File):
    program: t.List[str]
    variable_name: str

    def append_str(self, data: str) -> None:
        "Write a line of code to append this string to this file"
        self.program.append(f"{self.variable_name}.append_str('{data}')")

    def append_data(self, data: PPData) -> None:
        "Convert data to a variable name, and write a line of code to append it to this file"
        self.program.append(f"{self.variable_name}.append_data({data.variable_name})")

    def append_path(self, data: PPFile) -> None:
        "Convert data to a variable name, and write a line of code to append it to this file"
        self.program.append(f"{self.variable_name}.append_path({data.variable_name})")

@dataclass
class PPData(Data):
    variable_name: str
#+end_src

We can run =prog= with this implementation, picking arbitrary initial variable names:

#+begin_src python
def ppmain():
    program = []
    dir = PPDirectory(program, "mydir")
    arg1 = PPData("somearg")
    arg2 = PPData("otherarg")
    # run prog to pretty-print the program
    prog(dir, arg1, arg2)
    # wrap the pretty-printed program in a function declaration and print it to stdout
    print(f"def func({dir.variable_name}, {arg1.variable_name}, {arg2.variable_name}):")
    print("    " + "\n    ".join(program))
#+end_src

This outputs a pretty-printed program to stdout:

#+begin_src python
def func(mydir, somearg, otherarg):
    file0 = mydir.create_file('paths')
    file1 = mydir.create_file('arg1')
    file1.append_data(somearg)
    file0.append_data('arg1 file path:')
    file0.append_data(file1)
    file5 = mydir.create_file('arg2')
    file5.append_data(otherarg)
    file0.append_data('arg2 file path:')
    file0.append_data(file5)
#+end_src

Not the most beautiful pretty-printing,
but still pretty good considering that this works without access to the source code.

** Optimization
First, some background knowledge:
When writing to a filesystem, space must be allocated for data as it is written.
Writing data in many small chunks causes the space allocation to be broken up into many small chunks.
It is substantially more efficient to allocate space in one big chunk,
rather than in many small chunks.

Knowing that, we'd like to optimize our program to allocate all the space it needs for a file up front,
at the time it creates the file.

To do that, this implementation of =Data=, =Directory=, and =File= profiles the program it's passed to,
storing information about the space allocation implicitly performed by the program.
After the program is finished running with the profiling implementation,
the =optimized_dir= method returns a new =Directory= object
which uses that profiling information to perform space allocations in one big chunk at file creation,
instead of in smaller chunks.

#+begin_src python
@dataclass
class ProfilingDirectory(Directory):
    path: str
    files: t.Dict[str, ProfilingFile]

    def create_file(self, name: str) -> File:
        "Make a file which profiles the space usage of operations performed on it"
        path = self.path + "/" + name
        file = ProfilingFile(path)
        self.files[name] = file
        return file

    def optimized_dir(self, path: str) -> OptimizedDirectory:
        "Return an optimized directory which performs profiled space allocations all at once"
        return OptimizedDirectory(path, self.files)

@dataclass
class ProfilingFile(File):
    path: str
    size: int = 0

    def append_str(self, data: str) -> None:
        "Record how much file space writing this string would consume"
        self.size += len(data)

    def append_data(self, data: StrData) -> None:
        "Record how much file space writing this data would consume"
        self.append_str(data.content)

    def append_path(self, data: ProfilingFile) -> None:
        "Record how much file space writing this path would consume"
        self.append_str(data.path)

@dataclass
class OptimizedDirectory(IODirectory):
    profiler_results: t.Dict[str, ProfilingFile]

    def create_file(self, name: str) -> IOFile:
        "Create this file, allocating space in it based on data from profiling"
        profiler_result = self.profiler_results.get(name)
        if profiler_result:
            return super().create_file(name, size=profiler_result.size)
        else:
            return super().create_file(name)
#+end_src

We can use this profiler implementation to profile our program once,
and then run it many times.

#+begin_src python
def optimized_main():
    arg1 = StrData("somearg")
    arg2 = StrData("otherarg")
    profile_dir = ProfilingDirectory("somedir", {})
    prog(profile_dir, arg1, arg2)
    prog(profile_dir.optimized_dir("adir"), arg1, arg2)
    prog(profile_dir.optimized_dir("bdir"), arg1, arg2)
#+end_src

* Conclusion
Passing arguments to functions is fun and powerful.

Other constructs not shown in these examples,
such as control flow and lambdas,
can also be handled,
in general by ensuring that control flow or lambda creation is done through an interface.
For example, an if-check on an error code can be done with a =Result.or_else= interface,
which makes both branches visible to the implementation.
* Further reading
- [[http://okmij.org/ftp/tagless-final/index.html][Tagless-final style]].
  This is where I first learned about this technique.
- [[https://www.researchgate.net/publication/2302111_Type-Directed_Partial_Evaluation][Type-Directed Partial Evaluation]].
  This paper discusses (in part) the pretty-printing technique used here
  and how it can be generalized.
- [[http://www.object-oriented-security.org/lets-argue/singletons][Singletons Considered Harmful]].
  This post explains, in object-oriented terms,
  why it's preferable to pass dependencies as arguments rather than use globals.
* Addendum: Type-correct interfaces
The type declarations for the =Data=, =Directory=, and =File= interfaces at the start are simple and correct,
but need to be made a little more generic to support our implementations;
otherwise we get some type errors.

The below declarations of the interfaces are fully correct and allows us to typecheck properly.
But they're slightly more complicated, so we're doing it here to avoid confusion up front.

#+begin_src python
class Data:
    pass

T_Data = t.TypeVar('T_Data', bound=Data)
T_File = t.TypeVar('T_File', bound=File)
class File(t.Generic[T_Data]):
    def append_str (self,         data: str  ) -> None: ...
    def append_data(self,         data: T_Data) -> None: ...
    def append_path(self: T_File, data: T_File) -> None: ...

class Directory:
    def create_file(self, name: str) -> File: ...
#+end_src

Exercise for the reader:
Understand why these changes to the =append_data= and =append_path= methods are needed.

* Tagless final style (talk for !!con?) :noexport:
Title: {Compiling, testing, visualizing, whatevering} your program is easy, with tagless final style!

There are lots of cool things to do to programs! You can turn them into pretty pictures showing the control flow! You can compile them into more efficient programs! You can write tests to make sure they work properly!
All these are very different things, but one weird trick can let you do them all, and more, in any language!
The "tagless final style" trick lets you write a little bit of regular old code, and change your program to doing anything you want!
Then to make the picture, or recompile the program, or run a test - all you have to do is run the program!
Let's find out how!
** timeline
All examples will be in Python

0:00-1:00
- Basic explanation of tagless final style in terms of object-oriented programming in Python, no fancy types
- Very brief mention of: Paper and author coining it, and that it means the opposite of initial style
1:00-3:00
- Start of 3 examples (all in Python)
- First example: Compilation
- Show a function which calls a method on a passed-in object repeatedly to allocate some resources,
  then operates on the resources by calling more methods.
  That's slow; we'd prefer to batch-allocate the resources at the start.
- Pass it a different object;
  the different object records the allocation requests and returns resources which do nothing.
- Call the function with this new object and record the allocation requests;
  then we can make a new function with the same signature,
  which performs those allocations in a large batch all at once at the start,
  then passes them out one by one to the function.
  Way faster!
3:00-5:00
- Second example: Testing
- Show a function which performs some operations, which have some effect on the outside world,
  again by calling methods on a passed-in object
- Pass it a different object; its methods, instead of performing some effect,
  instead monitor the outside world until the corresponding effect is seen,
  and only then continue.
- Run the two instances of the function in parallel; if they both complete fine,
  then our implementation of the passed-in objects is correct!
5:00-8:00
- Third example: Visualization
- Show a function that calls a bunch of global functions from modules
- Show that we can intercept the lookup for those functions,
  and return some other Symbol objects instead which just contain the name of the variable that was looked up
- These objects return more Symbol objects every time they're interacted with, and also have a side-effect of making nodes and edges in a graph.
- To get a nice visualization of our function, then - just run it, and render the resulting graph!
8:00-10:00
- More background about tagless final style until I run out of time
- The alternative is parsing your code and building an AST! That is both slower and harder to do!
- There are many powerful techniques, too:
  - One cool thing is that this doesn't actually require us to have access to the source code!
    In theory, we could even visualize and pretty print compiled code!
  - This is also extensible! If we have a function which performs some new operations,
    we can reuse the old compilation/testing/visualization implementation,
    and just add on the new operations!
    Without having to change our old code!
    This is the expression problem - it's solved!
- Tagless final style is deeply related to:
  - Capabilities
  - Effect systems
  - Monads
** bio

Spencer Baugh always dreamed of being a programmer, and one day that dream became reality! Now Spencer finally knows what all those sci-fi books were talking about when they mentioned "linked lists" or "abstraction"! See http://catern.com for more from Spencer!
** thought about tagless final style
The alternative is to parse your code and inspect an AST.
But most programmers don't know how to do that.

But they do know how to implement objects with different implementations!
** type-based decompilation
   this is definitely an interesting one to include
** another example: turning tests into string descriptions
** post 1
   ok sooo

   I guess we just want to express in simple terms,
   hey, look here, there is this powerful technique,
   called tagless final style.

   and it's a generalization of general good style...

   well, yeah, I kind of view it as just a generalization of,
   type-directed programming/capability-based programming...

   like, just pass values to functions to do things.

   and use types

   ok, that's a bit deeper than I want to go really.
   I just want to say...

   Hey, there are some cool things you can do with tagless final style!
   And you don't need a fancily-typed language to do them!
   Basic OOP is sufficient for many.

   yeah but I don't want to spend a ton of time on it though
   because it's just a useful interesting fact.

   so maybe I just want to say, like...

   Many features that might seem to require parsing the code and doing static analysis on the resulting AST,
   can be done using tagless final style and normal code in the language,
   with small or no modifications to the program.

   Many interesting analysis or transformations on functions,
   such as compilation, visualization, or automatic test generation,
   seem to inherently require "stepping up to the meta-level",
   by parsing the function and statically analyzing the AST.
   In fact, such tasks can be done at the object-level,
   without parsing or static analysis,
   in any language,
   by simply calling the function with some unusual arguments.

   {Compilation,visualization,testing,etc} can be done at the ... with no parsing or static analysis

   at a level staying inside the formal semantics of the language?

   {Compilation,visualization,testing,etc} can be done inside the language

   To compile a function, pass it the correct arguments

   no that's more like the first sentence

   Compiling a program can be done without parsing it

   Static analysis can be done at runtime

   Compilation is just another way to run your program
   
   Compile your program by running it
   
   Compile your program by running it, not parsing it
   
   Reinterpret your program by running it, not with static analysis
   
   Interpret your program by running it, not with static analysis
   
   Replace static analysis with just running the program
   
   Implement an interpreter with no parsing?
   
   Argh all of this is just so abstract.
   
   The reality is so extremely concrete.
   
   A function that does something using objects you pass it, can be recompiled/reinterpreted/visualized by passing different objects.
   
   Write code, not compilers
   
   I guess?
   
   I mean it's similar to my other post on writing code instead of config,
   In that instead of doing some other thing, we're just passing objects.
   
   Yeah okay I like this as a provisional title.
   
   Write code, not compilers

   A program, represented as text, can be parsed and converted into some other form by a compiler.
   
    program, represented as a function,
   can be converted into some 

   A compiler parses a text file full of code, turns it into an AST,
   walks over the tree structure, and outputs some new thing.
   But you can skip straight to the "output some new thing" part,
   by writing regular code at the object level

   If you want to compile a program into some other form,
   you don't need to parse the program text and do static analysis.
   You can just write

   If you want to compile a program into some other form,
   your first step should be to just pass it different objects that make it do something different.

   (see that makes no sense. hm. hm hm.)

   "compilers are just special config for your program"
   truly bonkers lol

   If you want to compile a program into some other form,
   your first step should be to run it with a different interpretation.

   To compile a program into some other form,
   the easiest way is to run it,
   passing a different interpreter as an argument.

   To compile a function into some other form,
   sometimes the easiest way is to call it,
   passing a different arguments,
   such that the new form is returned from the function.

   This is not always powerful enough to round-trip the function.
   
   The fewer global variables and types that the function refers to,
   the more its behavior is determined by the arguments passed to it,
   and the more powerful transformations we can perform.


   A function is not just something...
   it describes its own behaviors....
   it acts on objects...

   A function does something using its arguments,
   and returns a value.

   A function is also a description of its own behavior.

   A function is a bundle of behaviors,
   taking in some arguments and outputting a value.

   A function is a description of its own behavior.
** good stuff
   A function does not need to be parsed and statically analyzed to figure out what it does.
   The function itself will tell you: Just call it and see.

   It will tell you in exactly the way you request
   In any way you request

   It will tell you in the way that you ask it:
   With the arguments you pass it.

   If you pass it objects and methods which perform IO and return unit,
   it will tell you in the language of side-effects.

   If you pass it objects and methods which pretty-print their arguments and return a string,
   it will tell you in the language of pretty-printed programs.

   If you pass it objects and methods which allocate registers and return instructions,
   it will tell you in the language of executable code.
** 
   yeah I like that! I like that a lot.
   a function is not just a bundle of functionality that does a thing!

   it's far more abstract than that.

   it's almost... something I have to unlearn...

   like, I've learned a notion of... a function doing a concrete thing,
   using concrete functionality that is provided to it.

   but the function is actually operating in a much more... abstracted space.

   For me,
   what I find tricky about understanding this,
   is that I usually think of a function as doing some specific, concrete thing,
   using the concrete capabilities that have been passed into it.

   But really, it's much more abstract than that.
** maybe intro
   To compile a function into some other form,
   sometimes the easiest way is to call it,
   passing a different arguments,
   such that the new form is returned from the function.
** other intro
   To convert a function into some other type
   (executable code, or a pretty-printed program, or something else),
   the easiest way is to call the function,
   passing certain arguments,
   such that the desired type is returned from the function.

   A function does not need to be parsed and statically analyzed to figure out what it does.
   The function itself will tell you: Just call it and see.

   It will tell you in the language that you ask for,
   using the arguments you pass it.

   If you pass it objects and methods which perform IO and return nothing,
   it will tell you in the language of side-effects.

   If you pass it objects and methods which pretty-print their arguments and return a string,
   it will tell you in the language of pretty-printed programs.

   If you pass it objects and methods which allocate registers and return instructions,
   it will tell you in the language of executable code.

   The fewer global variables and types that a function refers to,
   the more the function can speak in the language we desire,
   rather than a hard-coded predetermined langauge.
** nice
   okay nice I like that yeah

   okay let's stop updating the intro here and do it in the html only
** examples
   okay I think the main thing I actually need from here is examples.

   I think I can have one function that I'll use for all three examples.

   I can make a testing example too...

   yeah lol how was this not obvious to me before, just have one function and use it for all the examples.

   well... one reason that's not good is because,
   different functions have interfaces for different things,
   and therefore can support different transformations.

   still.

   I can do the string and compilation thing here...

   and... I can do the testing example maaaaybe.

   having a common example is really powerful but also limiting...

   the testing example shouldn't require anything new

   the string and compilation things require the same stuff

   so actually it seems fine yeah.

   the thing is that the *optimization* part, the up front allocation part,
   requires less abstraction than others.

   but, that's fine. we can ignore that.

   yeah hmmmmmmm

   yeah okay! I like this web application routes thing.
   lotta potential here.

   testing, we can test that the routes are pointing to the right objects,
   or something.

   the awkward thing with the webapp is that the familiar design has already been optimized
   for not being super bad performance, heh.

   hmmmmmmmm mm hmm hmm
   i'm sure we can figure out something to batch though

   hmmm

   oh! allocate space for routes and apps up front!
   just say, "allocate_route_space(3)", "allocate_app_space(2)"
   or maybe allocating an entire buffer, that might be clearer

   yeah and store it in the preallocation thing...

   hmm this webapp thing is not necessarily the best though,
   because it doesn't have side-effects.

   what about creating some files on disk? that could be good.

   and like...
   renaming them and stuff.

   and what would we all

   hmm hmm

   okay how about allocating the size of the file up front before writing?

   yeah that could be good

   ok ok cool so.

   we can allocate the space in the file for the paths up front.

   okay yeah I like this directory one

   Testing is done by:

   Test that the file contains the expected contents.

   okay so I like it, let's proceed from here.

   oh okay let's just narrow the file type in the method arguments, let's not assert it openly

   oh hey and we could even make that type safe later with a generic, actually.
*** how to type these examples?
    hmmmmmmmmMmmMmMmmm
    is it even possible in Python? with an OO type system?

    so... we want to say...
    we've got these interfaces, right...
    i mean it's the fact that we're peering inside. hm.

    oh so the...
    protocol or something should be...

    parameterized on the data? and... the file.

    so the file can...
    take itself as an argument.

    the

    that's gonna be tricky hmmmm

    or is it?

    ah no it's easy, duh, obvious in retrospect.

    well I still don't really know what that is desugaring into...
    (some kind of... existential package?
    sure, I guess an existential supports this directly)
*** another thought
    TFS is kind of like writing an effect handler

    and both of those are kind of like writing a pattern match over a function/expression.
*** citations?
    maybe I should cite some stuff, like...

    effect handlers/copattern matches

    tagless final style

    that one paper on type-directed decompilation
    or type directed partial evaluation?

    this will be a good singular reference
*** redesign of post
    let's just write a new one I guess

    or... write a separate post which shows examples?

    yeah and leave the koan as is.

    Should I link it from the main page?

    yes... on the same line.

    Write code, not compilers (examples)
* thoughts :noexport:
** merge examples into tfs article
  I guess this means unifying them into org-mode

  also I can cover some of the control flow things,
  and talk about handling lambdas by running "lam" on them.

  i can copy my discussion with simpson in erights
[[/home/sbaugh/.logs/#erights/2021-04-23.txt]]

okk so:

handling of:
control flow

yeah I just need to show an example showing an if statement.

hmmmmmm

or some kind of control flow...

something to remove doubt...

I mean so far I've avoided control flow in this way...

how about I just run the function twice?
thermometer-continuation style

but that's ugly

so what control flow is there?

if, for, throw, while
basic lambdas passed as arguments

I guessss I could do a for loop...

but... well a break wouldn't be a problem...

yeah I think a lambda would be a good example.

in some scenario where it's obvious that it's replacing control flow.

like a Result.map thing
or a List.map

yeah let's go with the Result thing, that's FUD-y enough that people won't question it,
everyone loves returning monadic errors days...

maybe I'll just say words

