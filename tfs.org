* Tagless final style (talk for !!con?)
Title: {Compiling, testing, visualizing, whatevering} your program is easy, with tagless final style!

There are lots of cool things to do to programs! You can turn them into pretty pictures showing the control flow! You can compile them into more efficient programs! You can write tests to make sure they work properly!
All these are very different things, but one weird trick can let you do them all, and more, in any language!
The "tagless final style" trick lets you write a little bit of regular old code, and change your program to doing anything you want!
Then to make the picture, or recompile the program, or run a test - all you have to do is run the program!
Let's find out how!
** timeline
All examples will be in Python

0:00-1:00
- Basic explanation of tagless final style in terms of object-oriented programming in Python, no fancy types
- Very brief mention of: Paper and author coining it, and that it means the opposite of initial style
1:00-3:00
- Start of 3 examples (all in Python)
- First example: Compilation
- Show a function which calls a method on a passed-in object repeatedly to allocate some resources,
  then operates on the resources by calling more methods.
  That's slow; we'd prefer to batch-allocate the resources at the start.
- Pass it a different object;
  the different object records the allocation requests and returns resources which do nothing.
- Call the function with this new object and record the allocation requests;
  then we can make a new function with the same signature,
  which performs those allocations in a large batch all at once at the start,
  then passes them out one by one to the function.
  Way faster!
3:00-5:00
- Second example: Testing
- Show a function which performs some operations, which have some effect on the outside world,
  again by calling methods on a passed-in object
- Pass it a different object; its methods, instead of performing some effect,
  instead monitor the outside world until the corresponding effect is seen,
  and only then continue.
- Run the two instances of the function in parallel; if they both complete fine,
  then our implementation of the passed-in objects is correct!
5:00-8:00
- Third example: Visualization
- Show a function that calls a bunch of global functions from modules
- Show that we can intercept the lookup for those functions,
  and return some other Symbol objects instead which just contain the name of the variable that was looked up
- These objects return more Symbol objects every time they're interacted with, and also have a side-effect of making nodes and edges in a graph.
- To get a nice visualization of our function, then - just run it, and render the resulting graph!
8:00-10:00
- More background about tagless final style until I run out of time
- The alternative is parsing your code and building an AST! That is both slower and harder to do!
- There are many powerful techniques, too:
  - One cool thing is that this doesn't actually require us to have access to the source code!
    In theory, we could even visualize and pretty print compiled code!
  - This is also extensible! If we have a function which performs some new operations,
    we can reuse the old compilation/testing/visualization implementation,
    and just add on the new operations!
    Without having to change our old code!
    This is the expression problem - it's solved!
- Tagless final style is deeply related to:
  - Capabilities
  - Effect systems
  - Monads
** bio

Spencer Baugh always dreamed of being a programmer, and one day that dream became reality! Now Spencer finally knows what all those sci-fi books were talking about when they mentioned "linked lists" or "abstraction"! See http://catern.com for more from Spencer!
** thought about tagless final style
The alternative is to parse your code and inspect an AST.
But most programmers don't know how to do that.

But they do know how to implement objects with different implementations!
** type-based decompilation
   this is definitely an interesting one to include
** another example: turning tests into string descriptions
** post 1
   ok sooo

   I guess we just want to express in simple terms,
   hey, look here, there is this powerful technique,
   called tagless final style.

   and it's a generalization of general good style...

   well, yeah, I kind of view it as just a generalization of,
   type-directed programming/capability-based programming...

   like, just pass values to functions to do things.

   and use types

   ok, that's a bit deeper than I want to go really.
   I just want to say...

   Hey, there are some cool things you can do with tagless final style!
   And you don't need a fancily-typed language to do them!
   Basic OOP is sufficient for many.

   yeah but I don't want to spend a ton of time on it though
   because it's just a useful interesting fact.

   so maybe I just want to say, like...

   Many features that might seem to require parsing the code and doing static analysis on the resulting AST,
   can be done using tagless final style and normal code in the language,
   with small or no modifications to the program.

   Many interesting analysis or transformations on functions,
   such as compilation, visualization, or automatic test generation,
   seem to inherently require "stepping up to the meta-level",
   by parsing the function and statically analyzing the AST.
   In fact, such tasks can be done at the object-level,
   without parsing or static analysis,
   in any language,
   by simply calling the function with some unusual arguments.

   {Compilation,visualization,testing,etc} can be done at the ... with no parsing or static analysis

   at a level staying inside the formal semantics of the language?

   {Compilation,visualization,testing,etc} can be done inside the language

   To compile a function, pass it the correct arguments

   no that's more like the first sentence

   Compiling a program can be done without parsing it

   Static analysis can be done at runtime

   Compilation is just another way to run your program
   
   Compile your program by running it
   
   Compile your program by running it, not parsing it
   
   Reinterpret your program by running it, not with static analysis
   
   Interpret your program by running it, not with static analysis
   
   Replace static analysis with just running the program
   
   Implement an interpreter with no parsing?
   
   Argh all of this is just so abstract.
   
   The reality is so extremely concrete.
   
   A function that does something using objects you pass it, can be recompiled/reinterpreted/visualized by passing different objects.
   
   Write code, not compilers
   
   I guess?
   
   I mean it's similar to my other post on writing code instead of config,
   In that instead of doing some other thing, we're just passing objects.
   
   Yeah okay I like this as a provisional title.
   
   Write code, not compilers

   A program, represented as text, can be parsed and converted into some other form by a compiler.
   
    program, represented as a function,
   can be converted into some 

   A compiler parses a text file full of code, turns it into an AST,
   walks over the tree structure, and outputs some new thing.
   But you can skip straight to the "output some new thing" part,
   by writing regular code at the object level

   If you want to compile a program into some other form,
   you don't need to parse the program text and do static analysis.
   You can just write

   If you want to compile a program into some other form,
   your first step should be to just pass it different objects that make it do something different.

   (see that makes no sense. hm. hm hm.)

   "compilers are just special config for your program"
   truly bonkers lol

   If you want to compile a program into some other form,
   your first step should be to run it with a different interpretation.

   To compile a program into some other form,
   the easiest way is to run it,
   passing a different interpreter as an argument.

   To compile a function into some other form,
   sometimes the easiest way is to call it,
   passing a different arguments,
   such that the new form is returned from the function.

   This is not always powerful enough to round-trip the function.
   
   The fewer global variables and types that the function refers to,
   the more its behavior is determined by the arguments passed to it,
   and the more powerful transformations we can perform.


   A function is not just something...
   it describes its own behaviors....
   it acts on objects...

   A function does something using its arguments,
   and returns a value.

   A function is also a description of its own behavior.

   A function is a bundle of behaviors,
   taking in some arguments and outputting a value.

   A function is a description of its own behavior.
** good stuff
   A function does not need to be parsed and statically analyzed to figure out what it does.
   The function itself will tell you: Just call it and see.

   It will tell you in exactly the way you request
   In any way you request

   It will tell you in the way that you ask it:
   With the arguments you pass it.

   If you pass it objects and methods which perform IO and return unit,
   it will tell you in the language of side-effects.

   If you pass it objects and methods which pretty-print their arguments and return a string,
   it will tell you in the language of pretty-printed programs.

   If you pass it objects and methods which allocate registers and return instructions,
   it will tell you in the language of executable code.
** 
   yeah I like that! I like that a lot.
   a function is not just a bundle of functionality that does a thing!

   it's far more abstract than that.

   it's almost... something I have to unlearn...

   like, I've learned a notion of... a function doing a concrete thing,
   using concrete functionality that is provided to it.

   but the function is actually operating in a much more... abstracted space.

   For me,
   what I find tricky about understanding this,
   is that I usually think of a function as doing some specific, concrete thing,
   using the concrete capabilities that have been passed into it.

   But really, it's much more abstract than that.
** maybe intro
   To compile a function into some other form,
   sometimes the easiest way is to call it,
   passing a different arguments,
   such that the new form is returned from the function.
** other intro
   To convert a function into some other type
   (executable code, or a pretty-printed program, or something else),
   the easiest way is to call the function,
   passing certain arguments,
   such that the desired type is returned from the function.

   A function does not need to be parsed and statically analyzed to figure out what it does.
   The function itself will tell you: Just call it and see.

   It will tell you in the language that you ask for,
   using the arguments you pass it.

   If you pass it objects and methods which perform IO and return nothing,
   it will tell you in the language of side-effects.

   If you pass it objects and methods which pretty-print their arguments and return a string,
   it will tell you in the language of pretty-printed programs.

   If you pass it objects and methods which allocate registers and return instructions,
   it will tell you in the language of executable code.

   The fewer global variables and types that a function refers to,
   the more the function can speak in the language we desire,
   rather than a hard-coded predetermined langauge.
** nice
   okay nice I like that yeah

   okay let's stop updating the intro here and do it in the html only
** examples
   okay I think the main thing I actually need from here is examples.

   I think I can have one function that I'll use for all three examples.

   I can make a testing example too...

   yeah lol how was this not obvious to me before, just have one function and use it for all the examples.

   well... one reason that's not good is because,
   different functions have interfaces for different things,
   and therefore can support different transformations.

   still.

   I can do the string and compilation thing here...

   and... I can do the testing example maaaaybe.

   having a common example is really powerful but also limiting...

   the testing example shouldn't require anything new

   the string and compilation things require the same stuff

   so actually it seems fine yeah.

   the thing is that the *optimization* part, the up front allocation part,
   requires less abstraction than others.

   but, that's fine. we can ignore that.

   yeah hmmmmmmm

   yeah okay! I like this web application routes thing.
   lotta potential here.

   testing, we can test that the routes are pointing to the right objects,
   or something.

   the awkward thing with the webapp is that the familiar design has already been optimized
   for not being super bad performance, heh.

   hmmmmmmmm mm hmm hmm
   i'm sure we can figure out something to batch though

   hmmm

   oh! allocate space for routes and apps up front!
   just say, "allocate_route_space(3)", "allocate_app_space(2)"
   or maybe allocating an entire buffer, that might be clearer

   yeah and store it in the preallocation thing...

   hmm this webapp thing is not necessarily the best though,
   because it doesn't have side-effects.

   what about creating some files on disk? that could be good.

   and like...
   renaming them and stuff.

   and what would we all

   hmm hmm

   okay how about allocating the size of the file up front before writing?

   yeah that could be good

   ok ok cool so.

   we can allocate the space in the file for the paths up front.

   okay yeah I like this directory one

   Testing is done by:

   Test that the file contains the expected contents.

   okay so I like it, let's proceed from here.

   oh okay let's just narrow the file type in the method arguments, let's not assert it openly

   oh hey and we could even make that type safe later with a generic, actually.
*** how to type these examples?
    hmmmmmmmmMmmMmMmmm
    is it even possible in Python? with an OO type system?

    so... we want to say...
    we've got these interfaces, right...
    i mean it's the fact that we're peering inside. hm.

    oh so the...
    protocol or something should be...

    parameterized on the data? and... the file.

    so the file can...
    take itself as an argument.

    the

    that's gonna be tricky hmmmm

    or is it?

    ah no it's easy, duh, obvious in retrospect.

    well I still don't really know what that is desugaring into...
    (some kind of... existential package?
    sure, I guess an existential supports this directly)
