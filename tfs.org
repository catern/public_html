#+title: Write code, not compilers
#+HTML_HEAD: <style type="text/css">pre.src {background-color: #303030; color: #ffffff;} body{ max-width:70em; margin-left:auto; margin-right:auto; }</style>

* Explanation
  :PROPERTIES:
  :CUSTOM_ID: explanation
  :END:
To convert a function into some other type
(executable code, or a pretty-printed string, or something else),
the easiest way is to call the function,
passing certain arguments,
such that the desired type is returned from the function.

A function does not need to be parsed and statically analyzed to figure out what it does.
The function itself will tell you: Just call it and see.

The function will speak to you in a language determined by the arguments you pass it.

- If you pass it objects and methods which perform IO and return unit,
  it will speak to you in the language of side-effects.
- If you pass it objects and methods which pretty-print their arguments and return a string,
  it will speak to you in the language of pretty-printed programs.
- If you pass it objects and methods which allocate registers and return instructions,
  it will speak to you in the language of executable code.

The fewer global variables and types that a function refers to,
the more the function can speak in the language you desire,
rather than a hard-coded predetermined langauge.

In this way, one can replace compilers,
which inspect syntax trees and operate on the meta-level,
with regular code operating on the object-level.
* Examples
  :PROPERTIES:
  :CUSTOM_ID: examples
  :END:
That koan alone may not bring you to enlightment,
so here's some examples
in working, type-annotated Python 3.
** The interface and program
   :PROPERTIES:
   :CUSTOM_ID: program
   :END:
First, an interface:
#+begin_src python
class Data:
    "Some opaque piece of data"
    pass

class Directory:
    "A directory, in which we can create files"
    def create_file(self, name: str) -> File: ...
    def for_each_file(self, f: t.Callable[[File], None]) -> None: ...

class File:
    "A file, to which we can append several types of values"
    def append_str (self, data: str ) -> None: ...
    def append_data(self, data: Data) -> None: ...
    def append_path(self, data: File) -> None: ...
    def close(self) -> None: ...
#+end_src

And a short program that uses that interface:
#+begin_src python
def create_file_with_contents(dir: Directory, name: str, arg: Data) -> File:
    "A helper function to create a file containing some data"
    file = dir.create_file(name)
    file.append_data(arg)
    return file

def prog(dir: Directory, arg1: Data, arg2: Data) -> None:
    "A simple program manipulating files and directories"
    paths = dir.create_file("paths")

    arg1_file = create_file_with_contents(dir, "arg1", arg1)
    paths.append_str("arg1 file path:")
    paths.append_path(arg1_file)
    arg1_file.close()

    arg2_file = create_file_with_contents(dir, "arg2", arg2)
    paths.append_str("arg2 file path:")
    paths.append_path(arg2_file)
    arg2_file.close()

    paths.append_str("all paths:")
    def f(file: File) -> None:
        paths.append_path(file)
        file.close()
    dir.for_each_file(f)

    paths.close()
#+end_src

By passing different implementations of the interfaces to this program,
we will reinterpret the program
as doing different things and producing different results.
** IO
   :PROPERTIES:
   :CUSTOM_ID: io
   :END:
First, the obvious implementation:
One which just writes to the filesystem.

#+begin_src python
@dataclass
class StrData(Data):
    "Some data, specifically a string"
    content: str

    def serialize(self) -> str:
        return self.content

@dataclass
class IODirectory(Directory):
    "A directory in the filesystem, in which we'll create files"
    path: str

    def create_file(self, name: str, size: int=None) -> IOFile:
        """Open and create a file in this directory in the filesystem

        An optional argument, size, will preallocate space in the file
        for future writes. We'll use this later.

        """
        path = self.path + "/" + name
        f = open(path, 'w')
        if size:
            f.truncate(size)
        return IOFile(path, f)

    def for_each_file(self, f: t.Callable[[File], None]) -> None:
        "Call `f` with each file in this directory"
        for name in os.listdir(self.path):
            path = self.path + "/" + name
            f(IOFile(path, open(path, 'r')))

@dataclass
class IOFile(File):
    "A file in the filesystem, to which we'll write"
    path: str
    file: t.TextIO

    def append_str(self, data: str) -> None:
        self.file.write(data)

    def append_data(self, data: StrData) -> None:
        self.file.write(data.content)

    def append_path(self, data: IOFile) -> None:
        self.file.write(data.path)

    def close(self) -> None:
        self.file.close()
#+end_src

We can then run =prog= with this implementation,
to get the expected behavior of making some files and writing into them.

#+begin_src python
def main():
    dir = IODirectory("/tmp/somedir")
    arg1 = StrData("my very cool and neat data")
    arg2 = StrData("some other kind of cool and neat data")
    prog(dir, arg1, arg2)
#+end_src

So far, this is all completely conventional.

** Testing
   :PROPERTIES:
   :CUSTOM_ID: testing
   :END:
We can pass an implementation which transforms our program into a test.
At each point, instead of performing an operation,
the program asserts that the operation has been performed correctly.

That's what the Test implementation does:
- Instead of creating a new file,
  we assert that the file is there.
- Instead of writing to the file,
  we read the file and assert its contents match our expectation.

This isn't a mock; it really does do IO in the filesystem,
just different IO.

#+begin_src python
@dataclass
class TestDirectory(Directory):
    "A directory in the filesystem, in which we'll open files"
    path: str

    def create_file(self, name: str) -> TestFile:
        """Open a file in this directory in the filesystem

        If the file doesn't exist, we'll throw an exception.

        """
        path = self.path + "/" + name
        # throws if the file doesn't exist
        f = open(path, 'r')
        return TestFile(path, f)

    def for_each_file(self, f: t.Callable[[File], None]) -> None:
        """Call `f` with each file in this directory.

        Same as for IODirectory.
        """
        for name in os.listdir(self.path):
            path = self.path + "/" + name
            f(TestFile(path, open(path, 'r')))

@dataclass
class TestFile(File):
    "A file in the filesystem, which we'll read from"
    path: str
    file: t.TextIO

    def append_str(self, data: str) -> None:
        """Assert this string matches the data in this file.

        As we read more data from the file, our position in the file
        moves forward and we read new data.

        """
        read_data = self.file.read(len(data))
        if data != read_data:
            raise Exception("the next data in the file should be", data, "not", read_data)

    def append_data(self, data: StrData) -> None:
        self.append_str(data.content)

    def append_path(self, data: TestFile) -> None:
        self.append_str(data.path)

    def close(self) -> None:
        self.file.close()
#+end_src

Now we can test the results of the IO implementation by running the Test implementation.

#+begin_src python
def testmain():
    dir = IODirectory("/tmp/somedir")
    arg1 = StrData("my very cool and neat data")
    arg2 = StrData("some other kind of cool and neat data")
    # run with IO
    prog(dir, arg1, arg2)
    # run with Test
    prog(TestDirectory(dir.path), arg1, arg2)
#+end_src

First we run =prog= once with IODirectory to create the files.
Then we run =prog= with TestDirectory to check that the files are there,
and have the correct contents.

** Pretty printing
   :PROPERTIES:
   :CUSTOM_ID: pprint
   :END:
This implementation of =Data=, =Directory=, and =File= pretty-prints the program that they are passed to.

Whenever a method is called,
this implementation writes a line of code which calls that method.
Variable names are generated to store any returned values,
and used when later method calls are made with those values.

#+begin_src python
class Program:
    statements: t.List[str]
    name: str

    def var(self, name: str) -> str:
        "Generate a fresh, unused variable name from this name"
        return self.name + "_" + name + str(len(self.statements))

    @contextlib.contextmanager
    def def_function(self, name: str, args: t.List[str]) -> str:
        """Helper for pretty-printing function definitions

        Statements performed inside this context manager are part of the
        function definition.

        """
        parent_statements, parent_name = self.statements, self.name
        self.statements, self.name = [], self.var(name)
        yield self.name
        parent_statements.append(
            f"def {self.name}(" + ", ".join(args) + "):\n" +
            textwrap.indent("\n".join(self.statements), "    "))
        self.statements, self.name = parent_statements, parent_name

@dataclass
class PPDirectory(Directory):
    "A staged directory, which writes lines of code to perform requested operations"
    program: Program
    variable_name: str

    def create_file(self, name: str) -> PPFile:
        "Write a line of code to call .create_file and store the result in an arbitrarily named variable"
        file = PPFile(self.program, self.program.var("file"))
        self.program.statements.append(f"{file.variable_name} = {self.variable_name}.create_file('{name}')")
        return file

    def for_each_file(self, f: t.Callable[[File], None]) -> None:
        "Render the passed function as a function definition, then write a line of code to call .for_each_file with it."
        file = PPFile(self.program, self.program.var("file"))
        with self.program.def_function('f', [file.variable_name]) as func_name:
            f(file)
        self.program.statements.append(f"{self.variable_name}.for_each_file({func_name})")

@dataclass
class PPFile(File):
    "A staged file, which writes lines of code to perform requested operations"
    program: Program
    variable_name: str

    def append_str(self, data: str) -> None:
        "Write a line of code to call .append_str with this string constant"
        self.program.statements.append(f"{self.variable_name}.append_str('{data}')")

    def append_data(self, data: PPData) -> None:
        "Convert data to a variable name, and write a line of code to call .append_str with it"
        self.program.statements.append(f"{self.variable_name}.append_data({data.variable_name})")

    def append_path(self, data: PPFile) -> None:
        "Convert data to a variable name, and write a line of code to call .append_path with it"
        self.program.statements.append(f"{self.variable_name}.append_path({data.variable_name})")

    def close(self) -> None:
        "Write a line of code to call .close"
        self.program.statements.append(f"{self.variable_name}.close()")

@dataclass
class PPData(Data):
    "A staged piece of data, which exists only as a variable name"
    variable_name: str
#+end_src

We can run =prog= with this implementation, picking arbitrary initial variable names:

#+begin_src python
def ppmain():
    program = Program([], "")
    dir = PPDirectory(program, "mydir")
    arg1 = PPData("somearg")
    arg2 = PPData("otherarg")
    with program.def_function('main', [dir.variable_name, arg1.variable_name, arg2.variable_name]):
        prog(dir, arg1, arg2)
    print(program.statements[0])
#+end_src

This outputs a pretty-printed program to stdout:

#+begin_src python
def _main0(mydir, somearg, otherarg):
    _main0_file0 = mydir.create_file('paths')
    _main0_file1 = mydir.create_file('arg1')
    _main0_file1.append_data(somearg)
    _main0_file0.append_str('arg1 file path:')
    _main0_file0.append_path(_main0_file1)
    _main0_file1.close()
    _main0_file6 = mydir.create_file('arg2')
    _main0_file6.append_data(otherarg)
    _main0_file0.append_str('arg2 file path:')
    _main0_file0.append_path(_main0_file6)
    _main0_file6.close()
    _main0_file0.append_str('all paths:')
    def _main0_f12(_main0_file12):
        _main0_file0.append_path(_main0_file12)
        _main0_file12.close()
    mydir.for_each_file(_main0_f12)
    _main0_file0.close()
#+end_src

Not the most beautiful pretty-printing,
but still pretty good considering that this works without access to the source code.

** Optimization
First, some background knowledge:
When writing to a filesystem, space must be allocated for data as it is written.
Writing data in many small chunks causes the space allocation to be broken up into many small chunks.
It is substantially more efficient to allocate space in one big chunk,
rather than in many small chunks.

Knowing that, we'd like to optimize our program to allocate all the space it needs for a file up front,
at the time it creates the file.

To do that, this implementation of =Data=, =Directory=, and =File= profiles the program it's passed to,
storing information about the space allocation implicitly performed by the program.
After the program is finished running with the profiling implementation,
the =optimized_dir= method returns a new =Directory= object
which uses that profiling information to perform space allocations in one big chunk at file creation,
instead of in smaller chunks.

#+begin_src python
@dataclass
class ProfilingDirectory(Directory):
    path: str
    files: t.Dict[str, ProfilingFile]

    def create_file(self, name: str) -> File:
        "Make a file which profiles the space usage of operations performed on it"
        path = self.path + "/" + name
        file = ProfilingFile(path)
        self.files[name] = file
        return file

    def for_each_file(self, f: t.Callable[[File], None]) -> None:
        "Does nothing; this depends on data in the filesystem, so we can't statically profile this"
        pass

    def optimized_dir(self, path: str) -> OptimizedDirectory:
        "Return an optimized directory which performs profiled space allocations all at once"
        return OptimizedDirectory(path, self.files)

@dataclass
class ProfilingFile(File):
    path: str
    size: int = 0

    def append_str(self, data: str) -> None:
        "Record how much file space writing this string would consume"
        self.size += len(data)

    def append_data(self, data: StrData) -> None:
        "Record how much file space writing this data would consume"
        self.append_str(data.content)

    def append_path(self, data: ProfilingFile) -> None:
        "Record how much file space writing this path would consume"
        self.append_str(data.path)

    def close(self) -> None:
        pass

@dataclass
class OptimizedDirectory(IODirectory):
    profiler_results: t.Dict[str, ProfilingFile]

    def create_file(self, name: str) -> IOFile:
        "Create this file, allocating space in it based on data from profiling"
        profiler_result = self.profiler_results.get(name)
        if profiler_result:
            return super().create_file(name, size=profiler_result.size)
        else:
            return super().create_file(name)
#+end_src

We can use this profiler implementation to profile our program once,
and then run it many times.

#+begin_src python
def optimized_main():
    arg1 = StrData("somearg")
    arg2 = StrData("otherarg")
    profile_dir = ProfilingDirectory("somedir", {})
    prog(profile_dir, arg1, arg2)
    prog(profile_dir.optimized_dir("adir"), arg1, arg2)
    prog(profile_dir.optimized_dir("bdir"), arg1, arg2)
#+end_src
** Linear type inference and checking
   :PROPERTIES:
   :CUSTOM_ID: types
   :END:
This implementation infers linear types for expressions and functions in our program,
and checks their consistency.
Specifically, we statically track the open/closed state of files
to ensure that files cannot be used after they are closed.

Note that the inferred linear types are not actually made explicit as data in the type-checker;
they are left implicit.
This allows a very simple typechecker implementation.

#+begin_src python
@dataclass
class TypecheckingDirectory(Directory):
    def create_file(self, name: str) -> TypecheckingFile:
        "Make a file which profiles the space usage of operations performed on it"
        return TypecheckingFile(open=True)

    def for_each_file(self, f: t.Callable[[File], None]) -> None:
        # run f to type check it against the input typestate...
        try:
            f(TypecheckingFile(open=True))
        except AssertionError:
            e.args = ("function passed to for_each_file uses closed file on the first run",)
            raise
        # ...and then run f again to check it against its own output typestate.
        try:
            f(TypecheckingFile(open=True))
        except AssertionError as e:
            e.args = ("function passed to for_each_file uses closed files on second and future runs",)
            raise

@dataclass
class TypecheckingFile(File):
    open: bool

    def append_str(self, data: str) -> None:
        assert self.open

    def append_data(self, data: Data) -> None:
        assert self.open

    def append_path(self, data: File) -> None:
        assert self.open

    def close(self) -> None:
        assert self.open
        self.open = False
#+end_src

Now we can run our program with =TypecheckingDirectory= to typecheck it.
To illustrate that this works,
we'll also run with =badprog=, which fails typechecking:

#+begin_src python
def badprog(dir: Directory) -> File:
    paths = dir.create_file("paths")
    def f(file: File) -> None:
        paths.append_path(file)
        # oops, we meant to close "file", not "paths"!
        paths.close()
    dir.for_each_file(f)
    return paths

def typechecking_main():
    prog(TypecheckingDirectory(), Data(), Data())
    try:
        badprog(TypecheckingDirectory())
    except Exception:
        pass
#+end_src

The failure in =badprog= is indicated with a regular Python exception,
thrown at type-checking time:

#+begin_src python
Traceback (most recent call last):
  File "tfs.py", line 416, in <module>
    typechecking_main()
  File "tfs.py", line 414, in typechecking_main
    badprog(TypecheckingDirectory())
  File "tfs.py", line 409, in badprog
    dir.for_each_file(f)
  File "tfs.py", line 381, in for_each_file
    f(TypecheckingFile(open=True))
  File "tfs.py", line 406, in f
    paths.append_path(file)
  File "tfs.py", line 397, in append_path
    assert self.open
AssertionError: function passed to for_each_file uses closed files on second and future runs
#+end_src

The stack trace tells us the concrete reason why type-checking fails for =badprog=:
=f= uses a closed file after its first run,
specifically =paths= in the =paths.append_path(file)= statement.
=paths= is closed because we called =paths.close()= at the end of =f=.
* Conclusion
  :PROPERTIES:
  :CUSTOM_ID: conclusion
  :END:
Passing arguments to functions is fun and powerful.

Other constructs not shown in these examples,
such as control flow and lambdas,
can also be handled,
in general by ensuring that control flow or lambda creation is done through an interface.
For example, an if-check on an error code can be done with a =Result.or_else= interface,
which makes both branches visible to the implementation.
* Further reading
  :PROPERTIES:
  :CUSTOM_ID: further_reading
  :END:
- [[http://okmij.org/ftp/tagless-final/index.html][Tagless-final style]].
  This is where I first learned about this technique.
- [[https://www.researchgate.net/publication/2302111_Type-Directed_Partial_Evaluation][Type-Directed Partial Evaluation]].
  This paper discusses (in part) the pretty-printing technique used here
  and how it can be generalized.
- [[http://okmij.org/ftp/Computation/types.html#sessions][Session types without sophistry]].
  This paper studies the type-checker implementation technique from this post in greater detail.
- [[http://www.object-oriented-security.org/lets-argue/singletons][Singletons Considered Harmful]].
  This post explains, in object-oriented terms,
  why it's preferable to pass dependencies as arguments rather than use globals.
* Addendum: Type-correct interfaces
  :PROPERTIES:
  :CUSTOM_ID: type-correct
  :END:
The type declarations for the =Data=, =Directory=, and =File= interfaces at the start are simple and correct,
but need to be made a little more generic to support our implementations;
otherwise we get some type errors.

The below declarations of the interfaces are fully correct and allows us to typecheck properly.
But they're slightly more complicated, so we're doing it here to avoid confusion up front.

#+begin_src python
class Data:
    pass

T_Data = t.TypeVar('T_Data', bound=Data)
T_File = t.TypeVar('T_File', bound=File)
class File(t.Generic[T_Data]):
    def append_str (self,         data: str  ) -> None: ...
    def append_data(self,         data: T_Data) -> None: ...
    def append_path(self: T_File, data: T_File) -> None: ...

class Directory:
    def create_file(self, name: str) -> File: ...
#+end_src

Exercise for the reader:
Understand why these changes to the =append_data= and =append_path= methods are needed.

* Tagless final style (talk for !!con?) :noexport:
Title: {Compiling, testing, visualizing, whatevering} your program is easy, with tagless final style!

There are lots of cool things to do to programs! You can turn them into pretty pictures showing the control flow! You can compile them into more efficient programs! You can write tests to make sure they work properly!
All these are very different things, but one weird trick can let you do them all, and more, in any language!
The "tagless final style" trick lets you write a little bit of regular old code, and change your program to doing anything you want!
Then to make the picture, or recompile the program, or run a test - all you have to do is run the program!
Let's find out how!
** timeline
All examples will be in Python

0:00-1:00
- Basic explanation of tagless final style in terms of object-oriented programming in Python, no fancy types
- Very brief mention of: Paper and author coining it, and that it means the opposite of initial style
1:00-3:00
- Start of 3 examples (all in Python)
- First example: Compilation
- Show a function which calls a method on a passed-in object repeatedly to allocate some resources,
  then operates on the resources by calling more methods.
  That's slow; we'd prefer to batch-allocate the resources at the start.
- Pass it a different object;
  the different object records the allocation requests and returns resources which do nothing.
- Call the function with this new object and record the allocation requests;
  then we can make a new function with the same signature,
  which performs those allocations in a large batch all at once at the start,
  then passes them out one by one to the function.
  Way faster!
3:00-5:00
- Second example: Testing
- Show a function which performs some operations, which have some effect on the outside world,
  again by calling methods on a passed-in object
- Pass it a different object; its methods, instead of performing some effect,
  instead monitor the outside world until the corresponding effect is seen,
  and only then continue.
- Run the two instances of the function in parallel; if they both complete fine,
  then our implementation of the passed-in objects is correct!
5:00-8:00
- Third example: Visualization
- Show a function that calls a bunch of global functions from modules
- Show that we can intercept the lookup for those functions,
  and return some other Symbol objects instead which just contain the name of the variable that was looked up
- These objects return more Symbol objects every time they're interacted with, and also have a side-effect of making nodes and edges in a graph.
- To get a nice visualization of our function, then - just run it, and render the resulting graph!
8:00-10:00
- More background about tagless final style until I run out of time
- The alternative is parsing your code and building an AST! That is both slower and harder to do!
- There are many powerful techniques, too:
  - One cool thing is that this doesn't actually require us to have access to the source code!
    In theory, we could even visualize and pretty print compiled code!
  - This is also extensible! If we have a function which performs some new operations,
    we can reuse the old compilation/testing/visualization implementation,
    and just add on the new operations!
    Without having to change our old code!
    This is the expression problem - it's solved!
- Tagless final style is deeply related to:
  - Capabilities
  - Effect systems
  - Monads
** bio

Spencer Baugh always dreamed of being a programmer, and one day that dream became reality! Now Spencer finally knows what all those sci-fi books were talking about when they mentioned "linked lists" or "abstraction"! See http://catern.com for more from Spencer!
** thought about tagless final style
The alternative is to parse your code and inspect an AST.
But most programmers don't know how to do that.

But they do know how to implement objects with different implementations!
** type-based decompilation
   this is definitely an interesting one to include
** another example: turning tests into string descriptions
** post 1
   ok sooo

   I guess we just want to express in simple terms,
   hey, look here, there is this powerful technique,
   called tagless final style.

   and it's a generalization of general good style...

   well, yeah, I kind of view it as just a generalization of,
   type-directed programming/capability-based programming...

   like, just pass values to functions to do things.

   and use types

   ok, that's a bit deeper than I want to go really.
   I just want to say...

   Hey, there are some cool things you can do with tagless final style!
   And you don't need a fancily-typed language to do them!
   Basic OOP is sufficient for many.

   yeah but I don't want to spend a ton of time on it though
   because it's just a useful interesting fact.

   so maybe I just want to say, like...

   Many features that might seem to require parsing the code and doing static analysis on the resulting AST,
   can be done using tagless final style and normal code in the language,
   with small or no modifications to the program.

   Many interesting analysis or transformations on functions,
   such as compilation, visualization, or automatic test generation,
   seem to inherently require "stepping up to the meta-level",
   by parsing the function and statically analyzing the AST.
   In fact, such tasks can be done at the object-level,
   without parsing or static analysis,
   in any language,
   by simply calling the function with some unusual arguments.

   {Compilation,visualization,testing,etc} can be done at the ... with no parsing or static analysis

   at a level staying inside the formal semantics of the language?

   {Compilation,visualization,testing,etc} can be done inside the language

   To compile a function, pass it the correct arguments

   no that's more like the first sentence

   Compiling a program can be done without parsing it

   Static analysis can be done at runtime

   Compilation is just another way to run your program
   
   Compile your program by running it
   
   Compile your program by running it, not parsing it
   
   Reinterpret your program by running it, not with static analysis
   
   Interpret your program by running it, not with static analysis
   
   Replace static analysis with just running the program
   
   Implement an interpreter with no parsing?
   
   Argh all of this is just so abstract.
   
   The reality is so extremely concrete.
   
   A function that does something using objects you pass it, can be recompiled/reinterpreted/visualized by passing different objects.
   
   Write code, not compilers
   
   I guess?
   
   I mean it's similar to my other post on writing code instead of config,
   In that instead of doing some other thing, we're just passing objects.
   
   Yeah okay I like this as a provisional title.
   
   Write code, not compilers

   A program, represented as text, can be parsed and converted into some other form by a compiler.
   
    program, represented as a function,
   can be converted into some 

   A compiler parses a text file full of code, turns it into an AST,
   walks over the tree structure, and outputs some new thing.
   But you can skip straight to the "output some new thing" part,
   by writing regular code at the object level

   If you want to compile a program into some other form,
   you don't need to parse the program text and do static analysis.
   You can just write

   If you want to compile a program into some other form,
   your first step should be to just pass it different objects that make it do something different.

   (see that makes no sense. hm. hm hm.)

   "compilers are just special config for your program"
   truly bonkers lol

   If you want to compile a program into some other form,
   your first step should be to run it with a different interpretation.

   To compile a program into some other form,
   the easiest way is to run it,
   passing a different interpreter as an argument.

   To compile a function into some other form,
   sometimes the easiest way is to call it,
   passing a different arguments,
   such that the new form is returned from the function.

   This is not always powerful enough to round-trip the function.
   
   The fewer global variables and types that the function refers to,
   the more its behavior is determined by the arguments passed to it,
   and the more powerful transformations we can perform.


   A function is not just something...
   it describes its own behaviors....
   it acts on objects...

   A function does something using its arguments,
   and returns a value.

   A function is also a description of its own behavior.

   A function is a bundle of behaviors,
   taking in some arguments and outputting a value.

   A function is a description of its own behavior.
** good stuff
   A function does not need to be parsed and statically analyzed to figure out what it does.
   The function itself will tell you: Just call it and see.

   It will tell you in exactly the way you request
   In any way you request

   It will tell you in the way that you ask it:
   With the arguments you pass it.

   If you pass it objects and methods which perform IO and return unit,
   it will tell you in the language of side-effects.

   If you pass it objects and methods which pretty-print their arguments and return a string,
   it will tell you in the language of pretty-printed programs.

   If you pass it objects and methods which allocate registers and return instructions,
   it will tell you in the language of executable code.
** 
   yeah I like that! I like that a lot.
   a function is not just a bundle of functionality that does a thing!

   it's far more abstract than that.

   it's almost... something I have to unlearn...

   like, I've learned a notion of... a function doing a concrete thing,
   using concrete functionality that is provided to it.

   but the function is actually operating in a much more... abstracted space.

   For me,
   what I find tricky about understanding this,
   is that I usually think of a function as doing some specific, concrete thing,
   using the concrete capabilities that have been passed into it.

   But really, it's much more abstract than that.
** maybe intro
   To compile a function into some other form,
   sometimes the easiest way is to call it,
   passing a different arguments,
   such that the new form is returned from the function.
** other intro
   To convert a function into some other type
   (executable code, or a pretty-printed program, or something else),
   the easiest way is to call the function,
   passing certain arguments,
   such that the desired type is returned from the function.

   A function does not need to be parsed and statically analyzed to figure out what it does.
   The function itself will tell you: Just call it and see.

   It will tell you in the language that you ask for,
   using the arguments you pass it.

   If you pass it objects and methods which perform IO and return nothing,
   it will tell you in the language of side-effects.

   If you pass it objects and methods which pretty-print their arguments and return a string,
   it will tell you in the language of pretty-printed programs.

   If you pass it objects and methods which allocate registers and return instructions,
   it will tell you in the language of executable code.

   The fewer global variables and types that a function refers to,
   the more the function can speak in the language we desire,
   rather than a hard-coded predetermined langauge.
** nice
   okay nice I like that yeah

   okay let's stop updating the intro here and do it in the html only
** examples
   okay I think the main thing I actually need from here is examples.

   I think I can have one function that I'll use for all three examples.

   I can make a testing example too...

   yeah lol how was this not obvious to me before, just have one function and use it for all the examples.

   well... one reason that's not good is because,
   different functions have interfaces for different things,
   and therefore can support different transformations.

   still.

   I can do the string and compilation thing here...

   and... I can do the testing example maaaaybe.

   having a common example is really powerful but also limiting...

   the testing example shouldn't require anything new

   the string and compilation things require the same stuff

   so actually it seems fine yeah.

   the thing is that the *optimization* part, the up front allocation part,
   requires less abstraction than others.

   but, that's fine. we can ignore that.

   yeah hmmmmmmm

   yeah okay! I like this web application routes thing.
   lotta potential here.

   testing, we can test that the routes are pointing to the right objects,
   or something.

   the awkward thing with the webapp is that the familiar design has already been optimized
   for not being super bad performance, heh.

   hmmmmmmmm mm hmm hmm
   i'm sure we can figure out something to batch though

   hmmm

   oh! allocate space for routes and apps up front!
   just say, "allocate_route_space(3)", "allocate_app_space(2)"
   or maybe allocating an entire buffer, that might be clearer

   yeah and store it in the preallocation thing...

   hmm this webapp thing is not necessarily the best though,
   because it doesn't have side-effects.

   what about creating some files on disk? that could be good.

   and like...
   renaming them and stuff.

   and what would we all

   hmm hmm

   okay how about allocating the size of the file up front before writing?

   yeah that could be good

   ok ok cool so.

   we can allocate the space in the file for the paths up front.

   okay yeah I like this directory one

   Testing is done by:

   Test that the file contains the expected contents.

   okay so I like it, let's proceed from here.

   oh okay let's just narrow the file type in the method arguments, let's not assert it openly

   oh hey and we could even make that type safe later with a generic, actually.
*** how to type these examples?
    hmmmmmmmmMmmMmMmmm
    is it even possible in Python? with an OO type system?

    so... we want to say...
    we've got these interfaces, right...
    i mean it's the fact that we're peering inside. hm.

    oh so the...
    protocol or something should be...

    parameterized on the data? and... the file.

    so the file can...
    take itself as an argument.

    the

    that's gonna be tricky hmmmm

    or is it?

    ah no it's easy, duh, obvious in retrospect.

    well I still don't really know what that is desugaring into...
    (some kind of... existential package?
    sure, I guess an existential supports this directly)
*** another thought
    TFS is kind of like writing an effect handler

    and both of those are kind of like writing a pattern match over a function/expression.
*** citations?
    maybe I should cite some stuff, like...

    effect handlers/copattern matches

    tagless final style

    that one paper on type-directed decompilation
    or type directed partial evaluation?

    this will be a good singular reference
*** redesign of post
    let's just write a new one I guess

    or... write a separate post which shows examples?

    yeah and leave the koan as is.

    Should I link it from the main page?

    yes... on the same line.

    Write code, not compilers (examples)
* thoughts :noexport:
** merge examples into tfs article
  I guess this means unifying them into org-mode

  also I can cover some of the control flow things,
  and talk about handling lambdas by running "lam" on them.

  i can copy my discussion with simpson in erights
[[/home/sbaugh/.logs/#erights/2021-04-23.txt]]

okk so:

handling of:
control flow

yeah I just need to show an example showing an if statement.

hmmmmmm

or some kind of control flow...

something to remove doubt...

I mean so far I've avoided control flow in this way...

how about I just run the function twice?
thermometer-continuation style

but that's ugly

so what control flow is there?

if, for, throw, while
basic lambdas passed as arguments

I guessss I could do a for loop...

but... well a break wouldn't be a problem...

yeah I think a lambda would be a good example.

in some scenario where it's obvious that it's replacing control flow.

like a Result.map thing
or a List.map

yeah let's go with the Result thing, that's FUD-y enough that people won't question it,
everyone loves returning monadic errors days...

maybe I'll just say words
** new list and types example
   so maybe we don't want to return a list from map,
   because, we can't introspect that list.

   hmm appending to a list is also bad

   what we really want is maybe,
   one function which writes each file A in dir to another file B and closes A,

   then we have another one which is a typo, which closes B instead of A.

   okay so for the trace for the mapfiles...
   that's a bit tricky because I need to change where the sideeffect of pushing a line of code,
   happens.

   okay, wait...

   how do we handle for_each_file with the test mode?

   oh it should just work fine.
   except, I guess, that the order is random. but still it should be fine,
   I'm not super concerned here...

   okay so we won't both checking that the file is closed...
   that's something we could do, but it's complex, so we won't bother.
   we'll just check it's affine.
   or... something like that, anyway.

   ah hm okay how about we mutate a dict, referenced from file,
   which maps files to open/closed.

   and then we assert... hmm...

   okay so...

   I'm not totally sure what's corrct here, hm.

   I guess...

   we run through maintaining the state of the variables...

   and then have some output typestate...

   maybe when we try to close something...
   we check that against the output? to see if we can add a closed there?

   nah... nah...

   let's just run it twice...

   yeah that's perfect!

   yeah so we can just describe this as some advanced typestate stuff.
   and, we don't actually make the type of each expression and function explicit,
   we just use the typestate directly.

   types are data
   type inference just extracts some form of data from the functions

   and then we use that data to do checking

   but why don't we just keep the data in the form of the function itself?
   ya...

* encoding more advanced types in TFS :noexport:
http://functorial.com/Embedding-a-Full-Linear-Lambda-Calculus-in-Haskell/linearlam.pdf

the encoding of existentials as universals is kinda like a lambda-encoding,
so it's promising

it would be cool to translate this linear lambda calculus to Python...

uhhhh they use some fancy type class machinery...

i don't know about a direct translation...

but it seems like it should be possible to break this stuff down!

in the same way that I broke down the typeclasses used in TFS, to just passing objects as arguments!
** email
Subject: TFS for DSLs with a more powerful type system than the host?

Hi Professor Kiselyov,

As preface,
I'm a huge fan of your work on tagless final style.
I use your techniques all the time 
and I've even worked on a basic pseudo-TFS tutorial for Python users: http://catern.com/tfs.html

I've often used, and suggested that others use, TFS to implement DSLs.
But when the DSLs has a more sophisticated type system than the host,
it's not clear to me how to do that.
I read with great interest your embedding of linear lambda calculus using TFS in
http://okmij.org/ftp/tagless-final/cookbook.html#linear
but I don't know how this technique would be generalized for,
e.g., dependent types, or modal types,
or other fancy type system features.

Is there a general way to use TFS (or other) techniques
such that a DSL can express type system features that aren't present than the host language?
Do you have any pointers to papers on this?

One thought I had along these lines is that perhaps just as TFS lambda-encodes data,
maybe all fancy type-system features could be "lambda-encoded" with universals,
in a generalization of the well-known encoding of existentials as universals.
But I don't know what such a generalization would look like.

Thanks,
Spencer Baugh


For example,
One thing that I've wondered about
** reply and paper
   hm staging

   but we'd really want to run those terms at "compile time"!
   along the rest of our typechecking/compilation process...

   hmm build steps...

   I do like the idea of writing an interpreter that just,
   does typechecks and stuff...
   and generates more code I guess.
   or, it doesn't really need to,
   since we can just have another interpreter to evaluate the code.
*** canonical structures
    like implicits but much more powerful?
    basically, proof search?
    interesting insight that typeclasses are proof search,
    that's going in the iceberg!

    so implicits are proof search...
    does this mean dynamic scope is proof search?
    hmmm........
    it does "search" up the stack...

    but I don't have alpha-equivalence, how do I remove the name and do type-based resolution instead?
    encode the type in the name?
    also it won't do synthesis...
*** asking lisp people
    I thought I recalled that one known technique for adding static type checking to a dynamic system like Lisp,
    was to do it through staging; static type checks become dynamic type checks in a staged code generator.
    Anyone have any papers/good examples of this in action?
**** hmm
     phrasing

     I think they phrase it as,
     "static checks are just dynamic checks at an earlier stage",
     so who needs the static checks?
*** hmm
    so really I just want to have... a type checker that interprets the program.

    I can insert type annotations with regular function calls, that's kinda cool.
    like, just have the type represented at the term level.
    and just separate the syntax classes with the meta-type-system.
*** example in python
    okay so I can have a map taking a function,
    and I can have it close the file,
    and I can show that results in an error.

    like... by closing it and then that breaks something?
    i'm not sure how that naturally works,
    but I'm sure there's a natural imperative way to do it.

    oh, maybe just run it twice?

    once to see the outputs,

    and once to see that the inputs match the outputs?

    is that... sound?

    sure! I mean, we need, uh, basically

    Γ, Δ ⊢ e : t, Δ

    like the inputs and the outputs are the same.

    ummmm

    or...
    i guess maybe we can just directly compare?

    yeah sure!

    we synthesize from the function,
    what objects it requires to be open,
    and what objects it closes.
    um, objects it closes are required to be open of course.

    so it can't really close anything. but, anyway.

    so we check the inputs against the outputs,
    and ensure those are the same. sure.

    okay so I guess I can add...

    close() to the main program...

    and a .map thing.

    I guess the .map will be... over... what?

    not sure.. I guess a file is the obvious choice.

    sure, yeah, easy... I guess... maybe...

    oh let's just add opendir.

    aha yes yes... we'll add opendir...

    and then maplines? hmm.
    sounds a bit complex...

    oh maybe we'll not add opendir,
    we'll just add mapfiles, kinda thing,
    and pass in another directory for it.

    or... maybe, MAYBE,
    we can have a mapfiles at the end?

    sure that could be good.

    so... yeah...
    mapfiles at the end... which... does what?
    I guess we iterate over the filenames and...
    maybe...
    write them somewhere?
    or no, we have to iterate over the files.

    ok so we iterate over the files.

    and at the end of the function we validate they're closed...
    and, yeah, if they aren't, we fail it.
**** further example
     actual dynamic type checking?
     could be interesting...

     as in, implementing a type system for Python in TFS-style

     but I think my basic example is better...

     on the other hand, having an actual use case for types in TFS would be better still

     but, still, it would be cool to have this example.
*** turnstile in racket
*** practical implementation details
    well okay so it's obviously quite annoying that,
    when you run your regular compiler,
    you get type errors,
    but you don't get type errors from the DSL.

    and... I guess this is just because, otherwise arbitrary user code could cause problems.
    although... people typically run macros at compile time and then type-check,
    so why shouldn't this be run at compile time??
** reply
   Very interesting, thank you for the link!
   I see how staged type-checking in this way could be extended to arbitrarily fancy type systems.
   I already can see how this technique could be used to add more sophisticated types
   to the embedded languages I've implemented with TFS,
   so thank you for handing me a ready solution!

   This is a very pedestrian concern, apologies,
   but do you anticipate that code generation for staged computations 
   would be run at "compile time" - for example, when ocamlc is run?
   Or would users need to run code generation as a separate step (perhaps once for each DSL term),
   and only get type errors at that step?
   It seems like the inability to run term-level computation at compile time
   would make this technique a little more awkward for users who might be expecting type errors.
   

   It seems that if there are many staged computations,
   it would be preferable for them

   and perhaps I missed this in your paper,
   but it seems that the additional staging steps may be annoying to users;
   running the compiler alone doesn't do all the type-checking,
   the user must also run code generation steps for all embedded DSLs.
   Do you anticipate that these code generation steps would be run at compile time?

   I notice the paper mentions proc_deploy
   

   For example, running the compi

   but it seems undesirable that running the type-checker the additional steps of staging might 

 it might be annoying to users to have to support these additional steps of staging.
   


   Apologies for this pedestrian concern. 
   but how 
    


