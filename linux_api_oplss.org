* TODO OPLSS participant talk
** DONE Scheduling OPLSS participant talk
Hi,

I have some work in a very early stage - developing a practically-useful formal
model of the Linux system call API.  I can describe the problem and the context
around it from an OS perspective, but I don't yet have much to say about how to
solve it with PL, and I'd love to hear ideas from others.  Would this be a good
participant talk?

Thanks,
Spencer Baugh

(response was "definitely")
** things they'll say
hey there's that posix io formal model thing.

or there's Ethos
** TODO plan it!!
ok
** abstract
no let's not start with this
** outline
okay so.

i guess we'll basically summarize my blog post?

one thing that's useful to focus on:
"IO-safety", capability-safety, etc.
that is, making sure you can't make system calls on the wrong file descriptor,
which would be just as bad and have much the same effects as writing to the wrong address.

i think that will be interesting.

but, also, emphasize that we have to model the existing system,
we can't just invent a new region system or whatever

also, I should engage with the posix IO model thing.
like... generating IO-safe interfaces from that would be difficult.
and also I feel like it... is missing some relevant information?
but I should dig into this.

also emphasize that this is very distinct from typing the data that flows through the kernel to other processes;
like the bytes that are in files at rest or in pipes.
that's not covered here at all,
that will still be raw unstructured bytes
(but of course that's something to improve too)

(maybe mention ioctls as an amusingly extremely-untyped interface)
** sandboxing?
i wonder if this model could be useful for sandboxing too, like seccomp syscalls...
** maybe
say that I got into this through wanting IO-safety when doing systems programming.

we want these rich powerful features,
in a type-safe language.
** outline
self-intro
brief project intro
background on OS stuff
talk about IO-safety
(this is very distinct from typing the data that flows through the kernel to other processes)

talk about other things that people like to do

talk about a description of the API making it easier to do those things

talk about the requirements:
- various fancy stuff
- architecture divergence
- maintainable by Linux kernel hackers

talk about some prior work (that POSIX fs model)

done.
** talk
*** self-intro
Hi, I'm Spencer Baugh.
I'm an independent researcher right now, I'll be working at Jane Street in 2023.
I'm interested in operating systems, distributed programming, and open source.
*** project intro
I'm going to talk a little bit about a project I've just started working on.

So this is a project to
add rich type information to the Linux kernel syscall API,
in a way that's practically useful for users calling those APIs.
Currently the API is mostly untyped and unsafe,
and I'd like to fix that.

So first,
I'll explain some background about the Linux syscall API,
starting with what that even is,
followed by an explanation of what's painful about the current untyped state,
and how adding richer types will help.

Then, some discussion of the requirements and hard parts in adding types to the Linux syscall API.
And then we'll be done.

I don't think I'll take up all the time,
so feel free to ask questions throughout,
and if there are any suggestions or ideas I'd love to hear them.
Like I said, this project is really just at the start.
*** Linux syscall API
OK, so starting from the top:
When I say Linux, I'm referring to the Linux kernel.
Most programs that run on computers, run on top of a kernel,
and interact with it via "system calls", also called a "syscall".
In some sense, a system call is just a function call:
You pass some arguments, which might include pointers to buffers or values in memory,
and you receive back a return value,
and additionally some side effects take place.

Suppose you want to make system calls available to programmers in some language.
There are two questions:
Typing: What is the type of a system call?  How can it be made type-safe?
Calling convention: How, exactly, is a system call performed?  What's the "protocol" we speak to the kernel?

Both of these questions about syscalls are important and necessary to answer,
but I'll ignore the calling convention question for a bit.

If we ignore the calling convention, we can assume we have something like this:
#+begin_src c
ssize_t read(int fd, void *buf, size_t count);
#+end_src
Which is a C function signature provided by the C standard library,
which wraps the "read" system call.
Given this,
we've already made some progress on answering the typing question,
by at least knowing the arity.
But: the C types on this wrapper are decidedly not type-safe.
*** safety
The integer "fd" is supposed to point to an open file descriptor.
"buf" and "count" are essentially a pointer to a writable buffer,
along with its size.

Most of the time, type-safe languages wrap =read= in an interface that abstracts the "buf" and "count" arguments away
in an effort to make =read= memory-safe.

But that's not all we need.
For true safety,
we need to ensure that an open file descriptor is passed to "fd"
rather than just an arbitrary integer.

Let me justify this a bit.
File descriptors are used for almost every kind of resource in the Linux API.
A library will frequently internally use some file descriptors for some purpose:
for example, to set a timer, or wait for events, or store data.

If "fd" is passed as just a raw integer,
any part of the program can call any system call on any file descriptor,
or make a system call with a file descriptor which isn't open,
or has been reused,
and get all kinds of unexpected corruption.
In exactly the same way that a lack of memory safety can corrupt your program,
break abstraction barriers,
and lead to security vulnerabilities.

So, for safety's sake,
=fd= needs to be passed as an abstract data type
which guarantees (either statically or dynamically)
that =fd= refers to an open file descriptor
that was received as a return value from some syscall
rather than being forged out of thin air.
This is sometimes called "capability safety" or "I/O safety".
https://rust-lang.github.io/rfcs/3128-io-safety.html

So then we have a safer wrapper for this system call.
We could go even further, to improve safety.
For example, we could look at the return value,
and use that to make access to the output buffer safer.
But we'll stop here.

Unfortunately, there's an issue:
The reasoning we just did,
we did informally and by hand.

And that's how it's always done:
Such abstractions are always hand-written,
based on a human reasoning about the system calls
based on information from the documentation and the implementation.

Hand-writing an abstraction for interacting with memory is fine;
there's a small number of primitive operations on memory.
So it's very possible to do.

But the system call API is extremely large,
and for most of it, there is *no* type-safe wrapper in *any* language,
let alone a type-safe wrapper in my language of choice.

This is bad because:
- It means programmers concerned with correctness,
  can't use advanced systems features that could simplify their programs.
- It means systems programmers who must use those features,
  are getting much less correctness in their programs.
*** a spec
So the goal here is to have safe interfaces for the entire Linux syscall API,
in every language,
without having to write those by hand.
This will make Linux features both more accessible and easier to use correctly.

To me, this suggests a two-step process:
1. Write down rich type information about system calls at least *once*, preferably in a language-independent way
2. Use that to generate idiomatic type-safe interfaces in many languages.

Step 1 is this project.
Step 2 is basically trivial if step 1 is completed well, so I'm ignoring it.

So our goal is to write down rich type information about system calls.

In addition to enabling safe interfaces for the entire Linux syscall API, doing this would:
- Allow new languages to easily do IO without needing to add a C FFI (always an annoying task)
- Improve the state of debugging tools (like strace) which also handwrite a bunch of knowledge about system calls
- Make it easier to systematically test and fuzz the Linux API
- Provide similar benefits for the many many other projects which intersect with the Linux syscall API
*** issues
OK!
So, what type information exactly do we need?

There are some clear things we want:
- We need to represent that some syscalls return open file descriptors and others close open file descriptors,
  some syscalls map memory and others unmap memory.
  Otherwise, we can't express what it means to pass an "open file descriptor" to a system call.
- We need some level of dependent types, for buffers and return values that are sized based on an argument.
  We might be able to get away with a constrained version only for buffer sizes.
- Critically, all this type information has to be maintainable by the expert C programmers that currently write the Linux kernel.
  Without this, these types will not be maintained for future changes and they'll become useless.
  One weird but maybe workable way to do this would be to embed these types as macros into the existing C code,
  and scrape them out.
  Somewhat similar things already exist in Linux, so it's not too weird.

Additionally, to really do this,
we also need to solve the calling convention question that I mentioned before:
Dealing with the concrete specifics of how a system call is invoked.
This requires support for lots of fine-grained details of memory layout, such as:
- Complex pointer-based datastructures that exist in memory
- Bit-level data formats
- Tagged unions
- Overloaded system calls such as ioctl, where the argument types are dependent on which constant enum value is passed
- Architecture-specific divergences from a mostly-common core

The system call interface has to be described *without* changing how it works,
so this is also an interesting problem of protocol description,
describing an existing protocol without changing its format.

So those are the things that are necessary for this project.
Rich typing information for each system call,
and a detailed description of the calling convetion for each system call.

I have some thoughts about how to approach this project,
but there's quite a lot of options.
So let me open it up to questions and comments.
*** related work
There are a number of papers that have presented formal models of POSIX APIs.

These formal models could in theory be used to automatically generate type-safe interfaces to modeled functions.
But there are a few issues:

- Most obviously, these papers don't specify the details of the calling convention,
  but instead abstract over it,
  so you wouldn't be able to actually generate much useful stuff just with them.
- More fundamentally, these papers cover only a very small part of the syscall API,
  which is our whole problem.
  Extending them would be difficult,
  because they contain much more information, because they're targeted at a harder problem
  than we're trying to solve.


**** papers
https://mgree.github.io/papers/popl2020_smoosh.pdf
https://6826.csail.mit.edu/2017/papers/sibylfs.pdf
*** misc

**** portability
(In many cases this gives up portability, but we want to do that)

**** not checked against implementation
But it's somewhat meaningful to note that this type information wouldn't necessarily be *checked*
against the implementation.
We just want a language to express the invariants,
which maybe is maintained by hand.
* abstract
title: Adding rich typing information to the Linux syscall API

The Linux syscall API is largely untyped and unsafe.
This makes it hard to use Linux operating system functionality in a safe way.
The traditional solution is to laboriously write safe syscall wrappers by hand in one's language of choice,
but most Linux functionality has no such safe wrapper in any language.

Instead, we can work upstream in Linux to create rich type information for the syscall API in a language-independent way,
then generate safe and idiomatic syscall wrappers in each language using that information.

Syscalls have complex behavior,
so the right way to express this type information is not clear.
I will discuss the motivation for this project and the issues that it faces,
and a few options for how to carry it out.
This project is in early stages, and I welcome suggestions.
