* TODO OPLSS participant talk
** DONE Scheduling OPLSS participant talk
Hi,

I have some work in a very early stage - developing a practically-useful formal
model of the Linux system call API.  I can describe the problem and the context
around it from an OS perspective, but I don't yet have much to say about how to
solve it with PL, and I'd love to hear ideas from others.  Would this be a good
participant talk?

Thanks,
Spencer Baugh

(response was "definitely")
** things they'll say
hey there's that posix io formal model thing.

or there's Ethos
** TODO plan it!!
ok
** abstract
no let's not start with this
** outline
okay so.

i guess we'll basically summarize my blog post?

one thing that's useful to focus on:
"IO-safety", capability-safety, etc.
that is, making sure you can't make system calls on the wrong file descriptor,
which would be just as bad and have much the same effects as writing to the wrong address.

i think that will be interesting.

but, also, emphasize that we have to model the existing system,
we can't just invent a new region system or whatever

also, I should engage with the posix IO model thing.
like... generating IO-safe interfaces from that would be difficult.
and also I feel like it... is missing some relevant information?
but I should dig into this.

also emphasize that this is very distinct from typing the data that flows through the kernel to other processes;
like the bytes that are in files at rest or in pipes.
that's not covered here at all,
that will still be raw unstructured bytes
(but of course that's something to improve too)

(maybe mention ioctls as an amusingly extremely-untyped interface)
** sandboxing?
i wonder if this model could be useful for sandboxing too, like seccomp syscalls...
** maybe
say that I got into this through wanting IO-safety when doing systems programming.

we want these rich powerful features,
in a type-safe language.
** outline
self-intro
brief project intro
background on OS stuff
talk about IO-safety
(this is very distinct from typing the data that flows through the kernel to other processes)

talk about other things that people like to do

talk about a description of the API making it easier to do those things

talk about the requirements:
- various fancy stuff
- architecture divergence
- maintainable by Linux kernel hackers

talk about some prior work (that POSIX fs model)

done.
** talk
*** self-intro
Hi, I'm Spencer Baugh.
I'm an independent researcher right now, working at Jane Street in 2023.
I'm interested in operating systems, distributed programming, and open source.
*** project intro
I'm going to talk a little bit about a project I've just started working on.

So this is a project to
add rich type information to the Linux kernel syscall API,
in a way that's practically useful for users calling those APIs.
Currently the API is mostly untyped and unsafe,
and I'd like to fix that.

So now,
I'll explain some background about the Linux syscall API,
starting with what the heck that even is,
followed by an explanation of what's painful about the current untyped state,
and how adding richer types will help.

Then, some discussion of the requirements and hard parts in adding types to the Linux syscall API.

I don't think I'll take up all the time,
so feel free to ask questions throughout,
and if there are any suggestions or ideas I'd love to hear them.
Like I said, this project is really just at the start.
*** Linux syscall API
OK, so starting from the top:
When I say Linux, I'm referring to the Linux kernel.
Most programs that run on computers, run on top of a kernel,
and interact with it via "system calls", also called a "syscall".
In some sense, a system call is just a function call:
You pass some arguments, which might include pointers to buffers or values in memory,
and receive back a return value.

Suppose you want to make system calls available to programmers in some language.
There are two questions:
Typing: What is the type of a system call?  How can it be made type-safe?
Calling convention: How, exactly, is a system call performed?  What's the "protocol" we speak to the kernel?

Both of these questions about syscalls are important and necessary to answer,
but I'll ignore the calling convention question for a bit.

If we ignore the calling convention, we can assume we have something like:
#+begin_quote
NAME
       read - read from a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t read(int fd, void *buf, size_t count);
#+end_quote
which is a wrapper for a system call.
Given this (which is a C function provided by the C standard library),
we've already made some progress on answering the typing question,
by at least knowing the arity.
But: the C types on this wrapper are decidedly not type-safe.
*** safety
The integer "fd" is supposed to point to an open file descriptor.
"buf" and "count" are essentially a pointer to a writable buffer,
along with its length.

Most of the time, type-safe languages wrap =read= in an interface that abstracts the "buf" and "count" arguments away
in an effort to make =read= memory-safe.

But that's not all we need.
For true safety,
we need to ensure that an open file descriptor is passed to "fd"
rather than just an arbitrary integer.

To justify this a bit:
File descriptors are used for almost every kind of resource in the Linux API.
A library will frequently internally use some file descriptors for some purpose:
for example, to set a timer, or wait for events, or store data.

If "fd" is passed as just a raw integer,
any part of the program can call any system call on any file descriptor,
or make a system call with a file descriptor which isn't open,
or has been reused,
and get all kinds of unexpected corruption.
In exactly the same way that a lack of memory safety can corrupt your program and lead to security vulnerabilities.

So, for safety's sake,
=fd= needs to be passed as an abstract data type which guarantees
(either statically or dynamically)
that =fd= refers to an open file descriptor.
The Rust community has called this property,
of it not being possible to pass invalid or forged handles,
"IO safety"
https://rust-lang.github.io/rfcs/3128-io-safety.html

So then we have a safer wrapper for this system call.
We could go even further, to improve safety.
For example, we could look at the return value,
and use that to make access to the output buffer safer.
But we'll stop here.

Unfortunately, there's an issue:
The reasoning we just did,
we did informally and by hand.

And that's how it's always done:
Such abstractions are always hand-written,
based on a human reasoning about the system calls
based on information from the documentation and the implementation.

Hand-writing an abstraction for interacting with memory is fine;
there's a small number of primitive operations on memory.
So it's very possible to do.

But the system call API is extremely large,
and for most of it, there is *no* type-safe wrapper in *any* language,
let alone a type-safe wrapper in my language of choice.

This is bad because:
- It means programmers concerned with correctness,
  can't use advanced systems features that could simplify their programs.
- It means systems programmers who must use those features,
  are getting much less correctness in their programs.
**** old
(In many cases this gives up portability, but we want to do that)
*** a spec
So the goal here is to have safe interfaces for the entire Linux syscall API,
in every language,
without having to write those by hand.

To me, this suggests a two-step process:
1. Write down rich type information about system calls at least *once*, preferably in a language-independent way
2. Use that to generate idiomatic type-safe interfaces in many languages.

Step 1 is this project.
Step 2 is basically trivial if step 1 is completed well, so I'm ignoring it.

So our goal is to write down rich type information about system calls.

In addition to enabling safe interfaces for the entire Linux syscall API, doing this would:
- Allow new languages to easily do IO without needing to add a C FFI
- Improve the state of debugging tools (such as strace) which also handwrite a bunch of knowledge about system calls
- Make it easier to systematically test and fuzz the Linux API
- Provide similar benefits for the many many other projects which intersect with the Linux syscall API
*** issues
OK!
So, what type information exactly do we need?

There are some clear things we want:
- We need to represent that some syscalls return open file descriptors and others close open file descriptors,
  some syscalls map memory and others unmap memory.
  Otherwise, we can't express what it means to pass an "open file descriptor" to a system call.
- We need some level of dependent types, for buffers and return values that are sized based on an argument.
  We may be able to get away with a constrained version only for buffer sizes.
- All this type information has to be maintainable by the expert C programmers that currently write the Linux kernel.
  Without this these types will not be maintained for each new syscall change and they'll become useless.
  One weird but maybe workable way to do this would be to embed these types as macros into the existing C code,
  and scrape them out.
  Somewhat similar things already exist in Linux.

Additionally, to really do this,
we also need to solve the calling convention question that I mentioned before:
Dealing with the concrete specifics of how a system call is invoked.
This requires support for lots of fine-grained details of memory layout, such as:
- Complex pointer-based datastructures that exist in memory
- Bit-level data formats
- Tagged unions
- Overloaded system calls such as ioctl, where the argument types are dependent on which constant enum value is passed
- Architecture-specific divergences from a mostly-common core

The system call interface has to be described *without* changing how it works,
so this is also a somewhat novel problem of protocol description,
describing an existing protocol without changing its format.

So those are the things that are necessary for this project.
Rich typing information that covers the effects that functions have on 
*** related work
There are a number of papers that have presented formal models of POSIX APIs.

These formal models could in theory be used to automatically generate type-safe interfaces to modeled functions.
But there are a few issues:

- Most obviously, these papers don't specify the details of the calling convention,
  but instead abstract over it,
  so you wouldn't be able to actually get far.
- More fundamentally, these papers cover only a very small part of the syscall API,
  which is our whole problem.
  Extending them would be difficult,
  because they contain much more information, because they're targeted at a harder problem
  than we're trying to solve.


*** misc
Such information would be useful for other things too:



But it's somewhat meaningful to note that this type information wouldn't necessarily be *checked*
against the implementation.
We just want a language to express the invariants,
which maybe is mainta

That information could also be useful for other things.

So, the fundamental issue here, in my view,
is that there is no description of what is *safe*






any part of the program can tamper

The Rust community has 



The most obvious is:
The 


Let's be clear:
This is not a system call.
This is a *wrapper* for a system call.
Internally,
this calls the Linux system call sys_read in an architecture-specific way,
in a way specific to sys_read.

How exactly that works.



This is the C function signature for a function implemented in glibc,
which *wraps* the underlying system calls to make them available to C.
Calling this function is what most people think of as "calling a system call",
but it's different.

The actual system call interface is sometimes very similar to the C interface,
and sometimes very different.

The actual system call interface, at least on the x86 architecture,
consists of setting some registers to appropriate values,
then invoking a dedicated syscall instruction.

That being said,
for common system calls the arguments passed to the C wrappers
and the arguments taken by the underlying system call are usually the same.



the basic C library that most C programs running on Linux

To call a system call, you need to execute some specifi


However, the calling convention for a system call
(that is, the exact instructions used to execute it)

The actual implementation

In practice, a system call 
*** [other]
The goal is not to benefit the Linux kernel itself, but rather userspace users
*** papers
https://mgree.github.io/papers/popl2020_smoosh.pdf
https://6826.csail.mit.edu/2017/papers/sibylfs.pdf
